!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
!
MODULE OAS_MAIN_B
  IMPLICIT NONE

CONTAINS
  SUBROUTINE MULT(nx, ny, x, y)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nx, ny
    REAL*8, INTENT(IN) :: x(nx)
    REAL*8, INTENT(OUT) :: y(ny)
    INTEGER :: i, j
    y(:) = 0.
    DO j=1,ny
      DO i=1,nx
        y(j) = y(j) + x(i)**2
      END DO
    END DO
  END SUBROUTINE MULT
!  Differentiation of assemblestructmtx_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: x
!   with respect to varying inputs: j x nodes iy iz rhs a
!   RW status of diff variables: j:out k:(loc) x:in-out nodes:out
!                iy:out iz:out rhs:out a:out
! 6
! 4
! 3
! 3
! 6
  SUBROUTINE ASSEMBLESTRUCTMTX_MAIN_B(n, tot_n_fem, size, nodes, nodesb&
&   , a, ab, j, jb, iy, iyb, iz, izb, k_a, k_t, k_y, k_z, elem_ids, cons&
&   , e, g, x_gl, t, k_elem, pelem_a, pelem_t, pelem_y, pelem_z, t_elem&
&   , const2, const_y, const_z, rhs, rhsb, k, kb, x, xb)
! 7
    USE SOLVEROUTINES, ONLY : solve
    IMPLICIT NONE
! Input
    INTEGER, INTENT(IN) :: n, size, cons, tot_n_fem
    INTEGER, INTENT(INOUT) :: elem_ids(n-1, 2)
    REAL(kind=8), INTENT(IN) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    REAL(kind=8) :: nodesb(tot_n_fem, 3), ab(n-1), jb(n-1), iyb(n-1), &
&   izb(n-1)
    REAL(kind=8), INTENT(IN) :: e(n-1), g(n-1), x_gl(3)
    REAL(kind=8) :: x_glb(3)
    REAL(kind=8), INTENT(INOUT) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    REAL(kind=8), INTENT(INOUT) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    REAL(kind=8), INTENT(IN) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    REAL(kind=8) :: pelem_ab(2, 12), pelem_tb(2, 12), pelem_yb(4, 12), &
&   pelem_zb(4, 12)
    REAL(kind=8), INTENT(IN) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4), rhs(size)
    REAL(kind=8) :: rhsb(size)
! Output
    REAL(kind=8) :: x(size), k(size, size)
    REAL(kind=8) :: xb(size), kb(size, size)
! Working
    REAL(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    REAL(kind=8) :: p0b(3), p1b(3), x_locb(3), y_locb(3), z_locb(3), &
&   x_crossb(3), y_crossb(3)
    REAL(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    REAL(kind=8) :: lb, ea_lb, gj_lb, eiy_l3b, eiz_l3b, resb(12, 12)
    REAL(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    REAL(kind=8) :: mat12x12b(12, 12), mat12x4b(12, 4), mat12x2b(12, 2)
    INTEGER :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    REAL(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(size, size)
    REAL(kind=8) :: pelem_a_tb(12, 2), pelem_t_tb(12, 2), k_b(size, size&
&   )
    REAL(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)&
&   , b(size)
    REAL(kind=8) :: pelem_y_tb(12, 4), pelem_z_tb(12, 4), t_elem_tb(12, &
&   12), bb(size)
    INTEGER :: ipiv(size), n_solve
    EXTERNAL SOLVE
    EXTERNAL SOLVE_B
    REAL(kind=8), DIMENSION(3) :: arg1
    REAL(kind=8), DIMENSION(3) :: arg1b
    REAL(kind=8) :: temp0
    REAL(kind=8) :: tb(3, 3)
    REAL(kind=8) :: k_elemb(12, 12)
    REAL(kind=8) :: k_yb(4, 4)
    REAL(kind=8) :: tempb2
    REAL(kind=8) :: tempb1
    REAL(kind=8) :: tempb0
    REAL(kind=8) :: tempb
    REAL(kind=8) :: k_ab(2, 2)
    REAL(kind=8) :: t_elemb(12, 12)
    REAL(kind=8) :: k_tb(2, 2)
    REAL(kind=8) :: k_zb(4, 4)
    REAL(kind=8) :: temp
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    k(:, :) = 0.
! loop over num elements
    DO ielem=1,num_elems
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      arg1(:) = p1 - p0
      CALL PUSHREAL8ARRAY(x_loc, 3)
      CALL UNIT(arg1(:), x_loc)
      CALL PUSHREAL8ARRAY(x_cross, 3)
      CALL CROSS(x_loc, x_gl, x_cross)
      CALL PUSHREAL8ARRAY(y_loc, 3)
      CALL UNIT(x_cross, y_loc)
      CALL PUSHREAL8ARRAY(y_cross, 3)
      CALL CROSS(x_loc, y_loc, y_cross)
      CALL UNIT(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      DO ind=1,4
        CALL PUSHREAL8ARRAY(t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:&
&                     3*(ind-1)+3), 3**2)
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      END DO
      arg1(:) = p1 - p0
      CALL PUSHREAL8(l)
      CALL NORM(arg1(:), l)
      ea_l = e(ielem)*a(ielem)/l
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      CALL PUSHREAL8ARRAY(k_y, 4**2)
      k_y(:, :) = eiy_l3*const_y
      CALL PUSHREAL8ARRAY(k_y(2, :), 4)
      k_y(2, :) = k_y(2, :)*l
      CALL PUSHREAL8ARRAY(k_y(4, :), 4)
      k_y(4, :) = k_y(4, :)*l
      CALL PUSHREAL8ARRAY(k_y(:, 2), 4)
      k_y(:, 2) = k_y(:, 2)*l
      CALL PUSHREAL8ARRAY(k_y(:, 4), 4)
      k_y(:, 4) = k_y(:, 4)*l
      CALL PUSHREAL8ARRAY(k_z, 4**2)
      k_z(:, :) = eiz_l3*const_z
      CALL PUSHREAL8ARRAY(k_z(2, :), 4)
      k_z(2, :) = k_z(2, :)*l
      CALL PUSHREAL8ARRAY(k_z(4, :), 4)
      k_z(4, :) = k_z(4, :)*l
      CALL PUSHREAL8ARRAY(k_z(:, 2), 4)
      k_z(:, 2) = k_z(:, 2)*l
      CALL PUSHREAL8ARRAY(k_z(:, 4), 4)
      k_z(:, 4) = k_z(:, 4)*l
      CALL PUSHREAL8ARRAY(k_elem, 12**2)
      k_elem(:, :) = 0.
      CALL PUSHREAL8ARRAY(pelem_a_t, 12*2)
      CALL TRANSPOSE2(2, 12, pelem_a, pelem_a_t)
      CALL PUSHREAL8ARRAY(mat12x2, 12*2)
      CALL MATMUL2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      CALL MATMUL2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      CALL PUSHREAL8ARRAY(pelem_t_t, 12*2)
      CALL TRANSPOSE2(2, 12, pelem_t, pelem_t_t)
      CALL PUSHREAL8ARRAY(mat12x2, 12*2)
      CALL MATMUL2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      CALL MATMUL2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      CALL PUSHREAL8ARRAY(pelem_y_t, 12*4)
      CALL TRANSPOSE2(4, 12, pelem_y, pelem_y_t)
      CALL PUSHREAL8ARRAY(mat12x4, 12*4)
      CALL MATMUL2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      CALL MATMUL2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      CALL PUSHREAL8ARRAY(pelem_z_t, 12*4)
      CALL TRANSPOSE2(4, 12, pelem_z, pelem_z_t)
      CALL PUSHREAL8ARRAY(mat12x4, 12*4)
      CALL MATMUL2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      CALL MATMUL2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      CALL PUSHREAL8ARRAY(t_elem_t, 12**2)
      CALL TRANSPOSE2(12, 12, t_elem, t_elem_t)
      CALL PUSHREAL8ARRAY(mat12x12, 12**2)
      CALL MATMUL2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      CALL MATMUL2(12, 12, 12, mat12x12, t_elem, res)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    END DO
    DO i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    END DO
    n_solve = size
    b = rhs
    k_ = k
    k_b = 0.0_8
    bb = 0.0_8
    CALL SOLVE_B(k_, k_b, x, xb, b, bb, n_solve, ipiv)
    kb = 0.0_8
    kb = k_b
    rhsb = 0.0_8
    rhsb = bb
    DO i=6,1,-1
      kb(6*cons+i, 6*num_nodes+i) = 0.0_8
      kb(6*num_nodes+i, 6*cons+i) = 0.0_8
    END DO
    jb = 0.0_8
    tb = 0.0_8
    t_elemb = 0.0_8
    nodesb = 0.0_8
    iyb = 0.0_8
    izb = 0.0_8
    ab = 0.0_8
    y_locb = 0.0_8
    z_locb = 0.0_8
    t_elem_tb = 0.0_8
    y_crossb = 0.0_8
    x_crossb = 0.0_8
    x_locb = 0.0_8
    DO ielem=num_elems,1,-1
      in1 = elem_ids(ielem, 2)
      resb = 0.0_8
      resb(7:12, 7:12) = resb(7:12, 7:12) + kb(6*(in1-1)+1:6*(in1-1)+6, &
&       6*(in1-1)+1:6*(in1-1)+6)
      in0 = elem_ids(ielem, 1)
      resb(1:6, 7:12) = resb(1:6, 7:12) + kb(6*(in0-1)+1:6*(in0-1)+6, 6*&
&       (in1-1)+1:6*(in1-1)+6)
      resb(7:12, 1:6) = resb(7:12, 1:6) + kb(6*(in1-1)+1:6*(in1-1)+6, 6*&
&       (in0-1)+1:6*(in0-1)+6)
      resb(1:6, 1:6) = resb(1:6, 1:6) + kb(6*(in0-1)+1:6*(in0-1)+6, 6*(&
&       in0-1)+1:6*(in0-1)+6)
      mat12x12b = 0.0_8
      CALL MATMUL2_B(12, 12, 12, mat12x12, mat12x12b, t_elem, t_elemb, &
&              res, resb)
      CALL POPREAL8ARRAY(mat12x12, 12**2)
      k_elemb = 0.0_8
      CALL MATMUL2_B(12, 12, 12, t_elem_t, t_elem_tb, k_elem, k_elemb, &
&              mat12x12, mat12x12b)
      CALL POPREAL8ARRAY(t_elem_t, 12**2)
      CALL TRANSPOSE2_B(12, 12, t_elem, t_elemb, t_elem_t, t_elem_tb)
      resb = 0.0_8
      resb = k_elemb
      mat12x4b = 0.0_8
      pelem_zb = 0.0_8
      CALL MATMUL2_B(12, 4, 12, mat12x4, mat12x4b, pelem_z, pelem_zb, &
&              res, resb)
      CALL POPREAL8ARRAY(mat12x4, 12*4)
      pelem_z_tb = 0.0_8
      k_zb = 0.0_8
      CALL MATMUL2_B(12, 4, 4, pelem_z_t, pelem_z_tb, k_z, k_zb, mat12x4&
&              , mat12x4b)
      CALL POPREAL8ARRAY(pelem_z_t, 12*4)
      resb = 0.0_8
      resb = k_elemb
      mat12x4b = 0.0_8
      pelem_yb = 0.0_8
      CALL MATMUL2_B(12, 4, 12, mat12x4, mat12x4b, pelem_y, pelem_yb, &
&              res, resb)
      CALL POPREAL8ARRAY(mat12x4, 12*4)
      pelem_y_tb = 0.0_8
      k_yb = 0.0_8
      CALL MATMUL2_B(12, 4, 4, pelem_y_t, pelem_y_tb, k_y, k_yb, mat12x4&
&              , mat12x4b)
      CALL POPREAL8ARRAY(pelem_y_t, 12*4)
      resb = 0.0_8
      resb = k_elemb
      mat12x2b = 0.0_8
      pelem_tb = 0.0_8
      CALL MATMUL2_B(12, 2, 12, mat12x2, mat12x2b, pelem_t, pelem_tb, &
&              res, resb)
      gj_l = g(ielem)*j(ielem)/l
      k_t(:, :) = gj_l*const2
      CALL POPREAL8ARRAY(mat12x2, 12*2)
      pelem_t_tb = 0.0_8
      k_tb = 0.0_8
      CALL MATMUL2_B(12, 2, 2, pelem_t_t, pelem_t_tb, k_t, k_tb, mat12x2&
&              , mat12x2b)
      CALL POPREAL8ARRAY(pelem_t_t, 12*2)
      resb = 0.0_8
      resb = k_elemb
      mat12x2b = 0.0_8
      pelem_ab = 0.0_8
      CALL MATMUL2_B(12, 2, 12, mat12x2, mat12x2b, pelem_a, pelem_ab, &
&              res, resb)
      ea_l = e(ielem)*a(ielem)/l
      k_a(:, :) = ea_l*const2
      CALL POPREAL8ARRAY(mat12x2, 12*2)
      pelem_a_tb = 0.0_8
      k_ab = 0.0_8
      CALL MATMUL2_B(12, 2, 2, pelem_a_t, pelem_a_tb, k_a, k_ab, mat12x2&
&              , mat12x2b)
      CALL POPREAL8ARRAY(pelem_a_t, 12*2)
      CALL POPREAL8ARRAY(k_elem, 12**2)
      CALL POPREAL8ARRAY(k_z(:, 4), 4)
      lb = SUM(k_z(:, 4)*k_zb(:, 4))
      k_zb(:, 4) = l*k_zb(:, 4)
      CALL POPREAL8ARRAY(k_z(:, 2), 4)
      lb = lb + SUM(k_z(:, 2)*k_zb(:, 2))
      k_zb(:, 2) = l*k_zb(:, 2)
      CALL POPREAL8ARRAY(k_z(4, :), 4)
      lb = lb + SUM(k_z(4, :)*k_zb(4, :))
      k_zb(4, :) = l*k_zb(4, :)
      CALL POPREAL8ARRAY(k_z(2, :), 4)
      lb = lb + SUM(k_z(2, :)*k_zb(2, :))
      k_zb(2, :) = l*k_zb(2, :)
      CALL POPREAL8ARRAY(k_z, 4**2)
      eiz_l3b = SUM(const_z*k_zb(:, :))
      CALL POPREAL8ARRAY(k_y(:, 4), 4)
      lb = lb + SUM(k_y(:, 4)*k_yb(:, 4))
      k_yb(:, 4) = l*k_yb(:, 4)
      CALL POPREAL8ARRAY(k_y(:, 2), 4)
      lb = lb + SUM(k_y(:, 2)*k_yb(:, 2))
      k_yb(:, 2) = l*k_yb(:, 2)
      CALL POPREAL8ARRAY(k_y(4, :), 4)
      lb = lb + SUM(k_y(4, :)*k_yb(4, :))
      k_yb(4, :) = l*k_yb(4, :)
      CALL POPREAL8ARRAY(k_y(2, :), 4)
      lb = lb + SUM(k_y(2, :)*k_yb(2, :))
      k_yb(2, :) = l*k_yb(2, :)
      CALL POPREAL8ARRAY(k_y, 4**2)
      eiy_l3b = SUM(const_y*k_yb(:, :))
      gj_lb = SUM(const2*k_tb(:, :))
      ea_lb = SUM(const2*k_ab(:, :))
      temp0 = l**3
      tempb = e(ielem)*eiz_l3b/temp0
      izb(ielem) = izb(ielem) + tempb
      temp = l**3
      tempb0 = e(ielem)*eiy_l3b/temp
      iyb(ielem) = iyb(ielem) + tempb0
      tempb2 = g(ielem)*gj_lb/l
      jb(ielem) = jb(ielem) + tempb2
      tempb1 = e(ielem)*ea_lb/l
      lb = lb - iy(ielem)*3*l**2*tempb0/temp - a(ielem)*tempb1/l - j(&
&       ielem)*tempb2/l - iz(ielem)*3*l**2*tempb/temp0
      ab(ielem) = ab(ielem) + tempb1
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      arg1(:) = p1 - p0
      CALL POPREAL8(l)
      arg1b = 0.0_8
      CALL NORM_B(arg1(:), arg1b(:), l, lb)
      p0b = 0.0_8
      p1b = 0.0_8
      p1b = arg1b(:)
      p0b = -arg1b(:)
      DO ind=4,1,-1
        CALL POPREAL8ARRAY(t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3&
&                    *(ind-1)+3), 3**2)
        tb = tb + t_elemb(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)&
&         +3)
        t_elemb(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = &
&         0.0_8
      END DO
      z_locb = z_locb + tb(3, :)
      tb(3, :) = 0.0_8
      y_locb = y_locb + tb(2, :)
      tb(2, :) = 0.0_8
      x_locb = x_locb + tb(1, :)
      tb(1, :) = 0.0_8
      CALL UNIT_B(y_cross, y_crossb, z_loc, z_locb)
      CALL POPREAL8ARRAY(y_cross, 3)
      CALL CROSS_B(x_loc, x_locb, y_loc, y_locb, y_cross, y_crossb)
      CALL POPREAL8ARRAY(y_loc, 3)
      CALL UNIT_B(x_cross, x_crossb, y_loc, y_locb)
      CALL POPREAL8ARRAY(x_cross, 3)
      x_glb = 0.0_8
      CALL CROSS_B(x_loc, x_locb, x_gl, x_glb, x_cross, x_crossb)
      arg1(:) = p1 - p0
      CALL POPREAL8ARRAY(x_loc, 3)
      arg1b = 0.0_8
      CALL UNIT_B(arg1(:), arg1b(:), x_loc, x_locb)
      p1b = p1b + arg1b
      p0b = p0b - arg1b
      nodesb(elem_ids(ielem, 2), :) = nodesb(elem_ids(ielem, 2), :) + &
&       p1b
      nodesb(elem_ids(ielem, 1), :) = nodesb(elem_ids(ielem, 1), :) + &
&       p0b
    END DO
  END SUBROUTINE ASSEMBLESTRUCTMTX_MAIN_B
! 6
! 4
! 3
! 3
! 6
  SUBROUTINE ASSEMBLESTRUCTMTX_MAIN(n, tot_n_fem, size, nodes, a, j, iy&
&   , iz, k_a, k_t, k_y, k_z, elem_ids, cons, e, g, x_gl, t, k_elem, &
&   pelem_a, pelem_t, pelem_y, pelem_z, t_elem, const2, const_y, const_z&
&   , rhs, k, x)
! 7
    USE SOLVEROUTINES_B, ONLY : solve
    IMPLICIT NONE
! Input
    INTEGER, INTENT(IN) :: n, size, cons, tot_n_fem
    INTEGER, INTENT(INOUT) :: elem_ids(n-1, 2)
    REAL(kind=8), INTENT(IN) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    REAL(kind=8), INTENT(IN) :: e(n-1), g(n-1), x_gl(3)
    REAL(kind=8), INTENT(INOUT) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    REAL(kind=8), INTENT(INOUT) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    REAL(kind=8), INTENT(IN) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    REAL(kind=8), INTENT(IN) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4), rhs(size)
! Output
    REAL(kind=8), INTENT(OUT) :: x(size), k(size, size)
! Working
    REAL(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    REAL(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    REAL(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    INTEGER :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    REAL(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(size, size)
    REAL(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)&
&   , b(size)
    INTEGER :: ipiv(size), n_solve
    EXTERNAL SOLVE
    REAL(kind=8), DIMENSION(3) :: arg1
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    k(:, :) = 0.
! loop over num elements
    DO ielem=1,num_elems
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      arg1(:) = p1 - p0
      CALL UNIT(arg1(:), x_loc)
      CALL CROSS(x_loc, x_gl, x_cross)
      CALL UNIT(x_cross, y_loc)
      CALL CROSS(x_loc, y_loc, y_cross)
      CALL UNIT(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      DO ind=1,4
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      END DO
      arg1(:) = p1 - p0
      CALL NORM(arg1(:), l)
      ea_l = e(ielem)*a(ielem)/l
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      k_y(:, :) = eiy_l3*const_y
      k_y(2, :) = k_y(2, :)*l
      k_y(4, :) = k_y(4, :)*l
      k_y(:, 2) = k_y(:, 2)*l
      k_y(:, 4) = k_y(:, 4)*l
      k_z(:, :) = eiz_l3*const_z
      k_z(2, :) = k_z(2, :)*l
      k_z(4, :) = k_z(4, :)*l
      k_z(:, 2) = k_z(:, 2)*l
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      CALL TRANSPOSE2(2, 12, pelem_a, pelem_a_t)
      CALL MATMUL2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      CALL MATMUL2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(2, 12, pelem_t, pelem_t_t)
      CALL MATMUL2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      CALL MATMUL2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(4, 12, pelem_y, pelem_y_t)
      CALL MATMUL2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      CALL MATMUL2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(4, 12, pelem_z, pelem_z_t)
      CALL MATMUL2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      CALL MATMUL2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(12, 12, t_elem, t_elem_t)
      CALL MATMUL2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      CALL MATMUL2(12, 12, 12, mat12x12, t_elem, res)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    END DO
    DO i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    END DO
    n_solve = size
    b = rhs
    k_ = k
    CALL SOLVE(k_, x, b, n_solve, ipiv)
  END SUBROUTINE ASSEMBLESTRUCTMTX_MAIN
!  Differentiation of transpose2 in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: new_mtx mtx
!   with respect to varying inputs: new_mtx mtx
  SUBROUTINE TRANSPOSE2_B(m, n, mtx, mtxb, new_mtx, new_mtxb)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: m, n
    REAL(kind=8), INTENT(IN) :: mtx(m, n)
    REAL(kind=8) :: mtxb(m, n)
    REAL(kind=8) :: new_mtx(n, m)
    REAL(kind=8) :: new_mtxb(n, m)
    INTEGER :: i, j
    DO i=m,1,-1
      DO j=n,1,-1
        mtxb(i, j) = mtxb(i, j) + new_mtxb(j, i)
        new_mtxb(j, i) = 0.0_8
      END DO
    END DO
  END SUBROUTINE TRANSPOSE2_B
  SUBROUTINE TRANSPOSE2(m, n, mtx, new_mtx)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: m, n
    REAL(kind=8), INTENT(IN) :: mtx(m, n)
    REAL(kind=8), INTENT(OUT) :: new_mtx(n, m)
    INTEGER :: i, j
    DO i=1,m
      DO j=1,n
        new_mtx(j, i) = mtx(i, j)
      END DO
    END DO
  END SUBROUTINE TRANSPOSE2
!  Differentiation of matmul2 in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b
  SUBROUTINE MATMUL2_B(m, n, p, a, ab, b, bb, c, cb)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: m, n, p
    REAL(kind=8), INTENT(IN) :: a(m, n), b(n, p)
    REAL(kind=8) :: ab(m, n), bb(n, p)
    REAL(kind=8) :: c(m, p)
    REAL(kind=8) :: cb(m, p)
    INTEGER :: i, j, k
    DO i=m,1,-1
      DO j=p,1,-1
        DO k=n,1,-1
          ab(i, k) = ab(i, k) + b(k, j)*cb(i, j)
          bb(k, j) = bb(k, j) + a(i, k)*cb(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE MATMUL2_B
  SUBROUTINE MATMUL2(m, n, p, a, b, c)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: m, n, p
    REAL(kind=8), INTENT(IN) :: a(m, n), b(n, p)
    REAL(kind=8), INTENT(OUT) :: c(m, p)
    INTEGER :: i, j, k
    c(:, :) = 0.
    DO i=1,m
      DO j=1,p
        DO k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        END DO
      END DO
    END DO
  END SUBROUTINE MATMUL2
  SUBROUTINE MATMUL2C(m, n, p, a, b, c)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: m, n, p
    COMPLEX(kind=8), INTENT(IN) :: a(m, n), b(n, p)
    COMPLEX(kind=8), INTENT(OUT) :: c(m, p)
    INTEGER :: i, j, k
    c(:, :) = 0.
    DO i=1,m
      DO j=1,p
        DO k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        END DO
      END DO
    END DO
  END SUBROUTINE MATMUL2C
!  Differentiation of assembleaeromtx_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: mtx
!   with respect to varying inputs: alpha points mesh bpts mtx
!   RW status of diff variables: alpha:out points:out mesh:out
!                bpts:out mtx:in-zero
  SUBROUTINE ASSEMBLEAEROMTX_MAIN_B(ny, nx, ny_, nx_, alpha, alphab, &
&   points, pointsb, bpts, bptsb, mesh, meshb, skip, symmetry, mtx, mtxb&
& )
    IMPLICIT NONE
! Input
    INTEGER, INTENT(IN) :: ny, nx, ny_, nx_
    COMPLEX(kind=8), INTENT(IN) :: alpha, mesh(nx_, ny_, 3)
    COMPLEX(kind=8) :: alphab, meshb(nx_, ny_, 3)
    COMPLEX(kind=8), INTENT(IN) :: points(nx-1, ny-1, 3), bpts(nx_-1, &
&   ny_, 3)
    COMPLEX(kind=8) :: pointsb(nx-1, ny-1, 3), bptsb(nx_-1, ny_, 3)
    LOGICAL, INTENT(IN) :: skip, symmetry
! Output
    COMPLEX(kind=8) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
    COMPLEX(kind=8) :: mtxb((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
! Working
    INTEGER :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    COMPLEX(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    COMPLEX(kind=8) :: pb(3), ab(3), bb(3), ub(3), cb(3), db(3)
    COMPLEX(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    COMPLEX(kind=8) :: a_symb(3), b_symb(3), c_symb(3), d_symb(3)
    COMPLEX(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    COMPLEX(kind=8) :: ur2b(3), r1b(3), r2b(3), r1_magb, r2_magb
    COMPLEX(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    COMPLEX(kind=8) :: ur1b(3), boundb(3), dot_ur2b, dot_ur1b
    COMPLEX(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym&
&   (3)
    COMPLEX(kind=8) :: edgesb(3), c_teb(3), d_teb(3), c_te_symb(3), &
&   d_te_symb(3)
    INTRINSIC ATAN
    INTRINSIC COS
    INTRINSIC SIN
    INTEGER :: branch
    COMPLEX(kind=8) :: tempb6
    COMPLEX(kind=8) :: tempb5(3)
    COMPLEX(kind=8) :: tempb4
    COMPLEX(kind=8) :: tempb3(3)
    COMPLEX(kind=8) :: tempb2
    COMPLEX(kind=8) :: tempb1(3)
    COMPLEX(kind=8) :: tempb0
    COMPLEX(kind=8) :: tempb(3)
    pi = 4.d0*ATAN(1.d0)
! Trailing vortices in AVL follow the x-axis; no cos or sin
    u(1) = COS(alpha*pi/180.)
    u(2) = 0.
    u(3) = SIN(alpha*pi/180.)
! spanwise loop through horseshoe elements
    DO el_j=1,ny_-1
      CALL PUSHINTEGER4(el_loc_j)
      el_loc_j = (el_j-1)*(nx_-1)
      CALL PUSHCOMPLEX16ARRAY(c_te, 3)
      c_te = mesh(nx_, el_j+1, :)
      CALL PUSHCOMPLEX16ARRAY(d_te, 3)
      d_te = mesh(nx_, el_j+0, :)
      IF (symmetry) THEN
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
! spanwise loop through control points
      DO cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        DO cp_i=1,nx-1
          CALL PUSHINTEGER4(cp_loc)
          cp_loc = cp_i + cp_loc_j
          CALL PUSHCOMPLEX16ARRAY(p, 3)
          p = points(cp_i, cp_j, :)
          CALL PUSHCOMPLEX16ARRAY(r1, 3)
          r1 = p - d_te
          CALL PUSHCOMPLEX16ARRAY(r2, 3)
          r2 = p - c_te
          CALL PUSHCOMPLEX16(r1_mag)
          CALL NORMC(r1, r1_mag)
          CALL PUSHCOMPLEX16(r2_mag)
          CALL NORMC(r2, r2_mag)
          CALL PUSHCOMPLEX16ARRAY(ur2, 3)
          CALL CROSSC(u, r2, ur2)
          CALL PUSHCOMPLEX16ARRAY(ur1, 3)
          CALL CROSSC(u, r1, ur1)
          CALL PUSHCOMPLEX16(dot_ur2)
          CALL DOTC(u, r2, dot_ur2)
          CALL PUSHCOMPLEX16(dot_ur1)
          CALL DOTC(u, r1, dot_ur1)
          IF (symmetry) THEN
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            CALL PUSHCOMPLEX16(r1_mag)
            CALL NORMC(r1, r1_mag)
            CALL PUSHCOMPLEX16(r2_mag)
            CALL NORMC(r2, r2_mag)
            CALL PUSHCOMPLEX16ARRAY(ur2, 3)
            CALL CROSSC(u, r2, ur2)
            CALL PUSHCOMPLEX16ARRAY(ur1, 3)
            CALL CROSSC(u, r1, ur1)
            CALL PUSHCOMPLEX16(dot_ur2)
            CALL DOTC(u, r2, dot_ur2)
            CALL PUSHCOMPLEX16(dot_ur1)
            CALL DOTC(u, r1, dot_ur1)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
! chordwise loop through horseshoe elements
          DO el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            IF (el_i .EQ. nx_ - 1) THEN
              CALL PUSHCOMPLEX16ARRAY(c, 3)
              c = c_te
              CALL PUSHCOMPLEX16ARRAY(d, 3)
              d = d_te
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCOMPLEX16ARRAY(c, 3)
              c = bpts(el_i+1, el_j+1, :)
              CALL PUSHCOMPLEX16ARRAY(d, 3)
              d = bpts(el_i+1, el_j+0, :)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (symmetry) THEN
              CALL PUSHCOMPLEX16ARRAY(a_sym, 3)
              a_sym = a
              CALL PUSHCOMPLEX16ARRAY(b_sym, 3)
              b_sym = b
              CALL PUSHCOMPLEX16ARRAY(c_sym, 3)
              c_sym = c
              CALL PUSHCOMPLEX16ARRAY(d_sym, 3)
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (skip .AND. cp_loc .EQ. el_loc) THEN
              IF (symmetry) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHCONTROL1B(1)
            ELSE
              IF (symmetry) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHCONTROL1B(0)
            END IF
          END DO
        END DO
      END DO
    END DO
    pointsb = (0.0_4,0.0_4)
    meshb = (0.0_4,0.0_4)
    bptsb = (0.0_4,0.0_4)
    ub = (0.0_4,0.0_4)
    ur1b = (0.0_4,0.0_4)
    ur2b = (0.0_4,0.0_4)
    a_symb = (0.0_4,0.0_4)
    c_te_symb = (0.0_4,0.0_4)
    b_symb = (0.0_4,0.0_4)
    d_te_symb = (0.0_4,0.0_4)
    DO el_j=ny_-1,1,-1
      c_teb = (0.0_4,0.0_4)
      d_teb = (0.0_4,0.0_4)
      DO cp_j=ny-1,1,-1
        DO cp_i=nx-1,1,-1
          pb = (0.0_4,0.0_4)
          edgesb = (0.0_4,0.0_4)
          DO el_i=1,nx_-1,1
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              el_loc = el_i + el_loc_j
              boundb = (0.0_4,0.0_4)
              edgesb = edgesb + mtxb(cp_loc, el_loc, :)
              boundb = mtxb(cp_loc, el_loc, :)
              mtxb(cp_loc, el_loc, :) = (0.0_4,0.0_4)
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) CALL CALC_VORTICITY_B(b_sym, b_symb, &
&                                                a_sym, a_symb, p, pb, &
&                                                bound, boundb)
              a = bpts(el_i+0, el_j+0, :)
              b = bpts(el_i+0, el_j+1, :)
              ab = (0.0_4,0.0_4)
              bb = (0.0_4,0.0_4)
              CALL CALC_VORTICITY_B(a, ab, b, bb, p, pb, bound, boundb)
            ELSE
              el_loc = el_i + el_loc_j
              boundb = (0.0_4,0.0_4)
              edgesb = edgesb + mtxb(cp_loc, el_loc, :)
              boundb = mtxb(cp_loc, el_loc, :)
              mtxb(cp_loc, el_loc, :) = (0.0_4,0.0_4)
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) CALL CALC_VORTICITY_B(b_sym, b_symb, &
&                                                a_sym, a_symb, p, pb, &
&                                                bound, boundb)
              a = bpts(el_i+0, el_j+0, :)
              b = bpts(el_i+0, el_j+1, :)
              ab = (0.0_4,0.0_4)
              bb = (0.0_4,0.0_4)
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              d_symb = (0.0_4,0.0_4)
              CALL CALC_VORTICITY_B(a_sym, a_symb, d_sym, d_symb, p, pb&
&                             , edges, edgesb)
              c_symb = (0.0_4,0.0_4)
              CALL CALC_VORTICITY_B(c_sym, c_symb, b_sym, b_symb, p, pb&
&                             , edges, edgesb)
              d_symb(2) = -d_symb(2)
              c_symb(2) = -c_symb(2)
              b_symb(2) = -b_symb(2)
              a_symb(2) = -a_symb(2)
              db = (0.0_4,0.0_4)
              CALL POPCOMPLEX16ARRAY(d_sym, 3)
              db = d_symb
              cb = (0.0_4,0.0_4)
              CALL POPCOMPLEX16ARRAY(c_sym, 3)
              cb = c_symb
              CALL POPCOMPLEX16ARRAY(b_sym, 3)
              bb = bb + b_symb
              CALL POPCOMPLEX16ARRAY(a_sym, 3)
              ab = ab + a_symb
              a_symb = (0.0_4,0.0_4)
              b_symb = (0.0_4,0.0_4)
            ELSE
              db = (0.0_4,0.0_4)
              cb = (0.0_4,0.0_4)
            END IF
            CALL CALC_VORTICITY_B(d, db, a, ab, p, pb, edges, edgesb)
            CALL CALC_VORTICITY_B(b, bb, c, cb, p, pb, edges, edgesb)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPCOMPLEX16ARRAY(d, 3)
              d_teb = d_teb + db
              CALL POPCOMPLEX16ARRAY(c, 3)
              c_teb = c_teb + cb
            ELSE
              CALL POPCOMPLEX16ARRAY(d, 3)
              bptsb(el_i+1, el_j+0, :) = bptsb(el_i+1, el_j+0, :) + db
              CALL POPCOMPLEX16ARRAY(c, 3)
              bptsb(el_i+1, el_j+1, :) = bptsb(el_i+1, el_j+1, :) + cb
            END IF
            bptsb(el_i+0, el_j+1, :) = bptsb(el_i+0, el_j+1, :) + bb
            bptsb(el_i+0, el_j+0, :) = bptsb(el_i+0, el_j+0, :) + ab
          END DO
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            tempb3 = edgesb/(r1_mag*(r1_mag-dot_ur1))
            tempb4 = SUM(-(ur1*tempb3/(r1_mag*(r1_mag-dot_ur1))))
            ur1b = ur1b + tempb3
            r1_magb = (2*r1_mag-dot_ur1)*tempb4
            dot_ur1b = -(r1_mag*tempb4)
            tempb5 = -(edgesb/(r2_mag*(r2_mag-dot_ur2)))
            tempb6 = SUM(-(ur2*tempb5/(r2_mag*(r2_mag-dot_ur2))))
            ur2b = ur2b + tempb5
            r2_magb = (2*r2_mag-dot_ur2)*tempb6
            dot_ur2b = -(r2_mag*tempb6)
            CALL POPCOMPLEX16(dot_ur1)
            r1b = (0.0_4,0.0_4)
            CALL DOTC_B(u, ub, r1, r1b, dot_ur1, dot_ur1b)
            CALL POPCOMPLEX16(dot_ur2)
            r2b = (0.0_4,0.0_4)
            CALL DOTC_B(u, ub, r2, r2b, dot_ur2, dot_ur2b)
            CALL POPCOMPLEX16ARRAY(ur1, 3)
            CALL CROSSC_B(u, ub, r1, r1b, ur1, ur1b)
            CALL POPCOMPLEX16ARRAY(ur2, 3)
            CALL CROSSC_B(u, ub, r2, r2b, ur2, ur2b)
            CALL POPCOMPLEX16(r2_mag)
            CALL NORMC_B(r2, r2b, r2_mag, r2_magb)
            CALL POPCOMPLEX16(r1_mag)
            CALL NORMC_B(r1, r1b, r1_mag, r1_magb)
            pb = pb + r1b + r2b
            c_te_symb = c_te_symb - r2b
            d_te_symb = d_te_symb - r1b
          END IF
          tempb = -(edgesb/(r1_mag*(r1_mag-dot_ur1)))
          tempb0 = SUM(-(ur1*tempb/(r1_mag*(r1_mag-dot_ur1))))
          ur1b = ur1b + tempb
          r1_magb = (2*r1_mag-dot_ur1)*tempb0
          dot_ur1b = -(r1_mag*tempb0)
          tempb1 = edgesb/(r2_mag*(r2_mag-dot_ur2))
          tempb2 = SUM(-(ur2*tempb1/(r2_mag*(r2_mag-dot_ur2))))
          ur2b = ur2b + tempb1
          r2_magb = (2*r2_mag-dot_ur2)*tempb2
          dot_ur2b = -(r2_mag*tempb2)
          r1 = p - d_te
          CALL POPCOMPLEX16(dot_ur1)
          r1b = (0.0_4,0.0_4)
          CALL DOTC_B(u, ub, r1, r1b, dot_ur1, dot_ur1b)
          r2 = p - c_te
          CALL POPCOMPLEX16(dot_ur2)
          r2b = (0.0_4,0.0_4)
          CALL DOTC_B(u, ub, r2, r2b, dot_ur2, dot_ur2b)
          CALL POPCOMPLEX16ARRAY(ur1, 3)
          CALL CROSSC_B(u, ub, r1, r1b, ur1, ur1b)
          CALL POPCOMPLEX16ARRAY(ur2, 3)
          CALL CROSSC_B(u, ub, r2, r2b, ur2, ur2b)
          CALL POPCOMPLEX16(r2_mag)
          CALL NORMC_B(r2, r2b, r2_mag, r2_magb)
          CALL POPCOMPLEX16(r1_mag)
          CALL NORMC_B(r1, r1b, r1_mag, r1_magb)
          CALL POPCOMPLEX16ARRAY(r2, 3)
          pb = pb + r1b + r2b
          c_teb = c_teb - r2b
          CALL POPCOMPLEX16ARRAY(r1, 3)
          d_teb = d_teb - r1b
          CALL POPCOMPLEX16ARRAY(p, 3)
          pointsb(cp_i, cp_j, :) = pointsb(cp_i, cp_j, :) + pb
          CALL POPINTEGER4(cp_loc)
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        d_te_symb(2) = -d_te_symb(2)
        c_te_symb(2) = -c_te_symb(2)
        d_teb = d_teb + d_te_symb
        c_teb = c_teb + c_te_symb
        c_te_symb = (0.0_4,0.0_4)
        d_te_symb = (0.0_4,0.0_4)
      END IF
      CALL POPCOMPLEX16ARRAY(d_te, 3)
      meshb(nx_, el_j+0, :) = meshb(nx_, el_j+0, :) + d_teb
      CALL POPCOMPLEX16ARRAY(c_te, 3)
      meshb(nx_, el_j+1, :) = meshb(nx_, el_j+1, :) + c_teb
      CALL POPINTEGER4(el_loc_j)
    END DO
    alphab = pi*COS(pi*(alpha/180.))*ub(3)/180.
    ub(3) = 0.0_8
    ub(2) = 0.0_8
    alphab = alphab - pi*SIN(pi*(alpha/180.))*ub(1)/180.
    mtxb = (0.0_4,0.0_4)
  END SUBROUTINE ASSEMBLEAEROMTX_MAIN_B
  SUBROUTINE ASSEMBLEAEROMTX_MAIN(ny, nx, ny_, nx_, alpha, points, bpts&
&   , mesh, skip, symmetry, mtx)
    IMPLICIT NONE
! Input
    INTEGER, INTENT(IN) :: ny, nx, ny_, nx_
    COMPLEX(kind=8), INTENT(IN) :: alpha, mesh(nx_, ny_, 3)
    COMPLEX(kind=8), INTENT(IN) :: points(nx-1, ny-1, 3), bpts(nx_-1, &
&   ny_, 3)
    LOGICAL, INTENT(IN) :: skip, symmetry
! Output
    COMPLEX(kind=8), INTENT(OUT) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), &
&   3)
! Working
    INTEGER :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    COMPLEX(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    COMPLEX(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    COMPLEX(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    COMPLEX(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    COMPLEX(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym&
&   (3)
    INTRINSIC ATAN
    INTRINSIC COS
    INTRINSIC SIN
    pi = 4.d0*ATAN(1.d0)
! Trailing vortices in AVL follow the x-axis; no cos or sin
    u(1) = COS(alpha*pi/180.)
    u(2) = 0.
    u(3) = SIN(alpha*pi/180.)
    mtx(:, :, :) = 0.
! spanwise loop through horseshoe elements
    DO el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_te = mesh(nx_, el_j+1, :)
      d_te = mesh(nx_, el_j+0, :)
      IF (symmetry) THEN
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
      END IF
! spanwise loop through control points
      DO cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        DO cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          p = points(cp_i, cp_j, :)
          r1 = p - d_te
          r2 = p - c_te
          CALL NORMC(r1, r1_mag)
          CALL NORMC(r2, r2_mag)
          CALL CROSSC(u, r2, ur2)
          CALL CROSSC(u, r1, ur1)
          edges(:) = 0.
          CALL DOTC(u, r2, dot_ur2)
          CALL DOTC(u, r1, dot_ur1)
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          IF (symmetry) THEN
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            CALL NORMC(r1, r1_mag)
            CALL NORMC(r2, r2_mag)
            CALL CROSSC(u, r2, ur2)
            CALL CROSSC(u, r1, ur1)
            CALL DOTC(u, r2, dot_ur2)
            CALL DOTC(u, r1, dot_ur1)
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          END IF
! chordwise loop through horseshoe elements
          DO el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            IF (el_i .EQ. nx_ - 1) THEN
              c = c_te
              d = d_te
            ELSE
              c = bpts(el_i+1, el_j+1, :)
              d = bpts(el_i+1, el_j+0, :)
            END IF
            CALL CALC_VORTICITY(b, c, p, edges)
            CALL CALC_VORTICITY(d, a, p, edges)
            IF (symmetry) THEN
              a_sym = a
              b_sym = b
              c_sym = c
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              CALL CALC_VORTICITY(c_sym, b_sym, p, edges)
              CALL CALC_VORTICITY(a_sym, d_sym, p, edges)
            END IF
            IF (skip .AND. cp_loc .EQ. el_loc) THEN
              bound(:) = 0.
              IF (symmetry) CALL CALC_VORTICITY(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            ELSE
              bound(:) = 0.
              CALL CALC_VORTICITY(a, b, p, bound)
              IF (symmetry) CALL CALC_VORTICITY(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            END IF
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE ASSEMBLEAEROMTX_MAIN
!  Differentiation of calc_vorticity in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: p out a b
!   with respect to varying inputs: p out a b
  SUBROUTINE CALC_VORTICITY_B(a, ab, b, bb, p, pb, out, outb)
    IMPLICIT NONE
! Input
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3), p(3)
    COMPLEX(kind=8) :: ab(3), bb(3), pb(3)
! Output
    COMPLEX(kind=8), INTENT(INOUT) :: out(3)
    COMPLEX(kind=8) :: outb(3)
! Working
    COMPLEX(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    COMPLEX(kind=8) :: r1b(3), r2b(3), r1_magb, r2_magb, r1r2b(3), &
&   mag_multb, dot_r1r2b
    COMPLEX(kind=8) :: tempb0
    COMPLEX(kind=8) :: tempb(3)
    r1 = p - a
    r2 = p - b
    CALL NORMC(r1, r1_mag)
    CALL NORMC(r2, r2_mag)
    CALL CROSSC(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    CALL DOTC(r1, r2, dot_r1r2)
    r1r2b = (0.0_4,0.0_4)
    tempb = outb/(mag_mult*(mag_mult+dot_r1r2))
    tempb0 = SUM(-((r1_mag+r2_mag)*r1r2*tempb/(mag_mult*(mag_mult+&
&     dot_r1r2))))
    r1r2b = (r1_mag+r2_mag)*tempb
    mag_multb = (2*mag_mult+dot_r1r2)*tempb0
    r1_magb = r2_mag*mag_multb + SUM(r1r2*tempb)
    r2_magb = r1_mag*mag_multb + SUM(r1r2*tempb)
    dot_r1r2b = mag_mult*tempb0
    r1b = (0.0_4,0.0_4)
    r2b = (0.0_4,0.0_4)
    CALL DOTC_B(r1, r1b, r2, r2b, dot_r1r2, dot_r1r2b)
    CALL CROSSC_B(r1, r1b, r2, r2b, r1r2, r1r2b)
    CALL NORMC_B(r2, r2b, r2_mag, r2_magb)
    CALL NORMC_B(r1, r1b, r1_mag, r1_magb)
    pb = pb + r1b + r2b
    bb = bb - r2b
    ab = ab - r1b
  END SUBROUTINE CALC_VORTICITY_B
  SUBROUTINE CALC_VORTICITY(a, b, p, out)
    IMPLICIT NONE
! Input
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3), p(3)
! Output
    COMPLEX(kind=8), INTENT(INOUT) :: out(3)
! Working
    COMPLEX(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    r1 = p - a
    r2 = p - b
    CALL NORMC(r1, r1_mag)
    CALL NORMC(r2, r2_mag)
    CALL CROSSC(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    CALL DOTC(r1, r2, dot_r1r2)
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  END SUBROUTINE CALC_VORTICITY
  SUBROUTINE BIOTSAVART(a, b, p, inf, rev, out)
    IMPLICIT NONE
! Input
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3), p(3)
    LOGICAL, INTENT(IN) :: inf, rev
! Output
    COMPLEX(kind=8), INTENT(INOUT) :: out(3)
! Working
    COMPLEX(kind=8) :: rpa, rpb, rab, rh
    COMPLEX(kind=8) :: cosa, cosb, c(3)
    COMPLEX(kind=8) :: eps, tmp(3), dot_bapa, dot_baba, dot_pbab
    COMPLEX(kind=8), DIMENSION(3) :: arg1
    COMPLEX(kind=8), DIMENSION(3) :: arg2
    eps = 1e-5
    arg1(:) = a - p
    CALL NORMC(arg1(:), rpa)
    arg1(:) = b - p
    CALL NORMC(arg1(:), rpb)
    arg1(:) = b - a
    CALL NORMC(arg1(:), rab)
    arg1(:) = b - a
    arg2(:) = p - a
    CALL DOTC(arg1(:), arg2(:), dot_bapa)
    arg1(:) = b - a
    arg2(:) = b - a
    CALL DOTC(arg1(:), arg2(:), dot_baba)
    arg1(:) = p - b
    arg2(:) = a - b
    CALL DOTC(arg1(:), arg2(:), dot_pbab)
    arg1(:) = p - a - dot_bapa/dot_baba*(b-a)
    CALL NORMC(arg1(:), rh)
    rh = rh + eps
    cosa = dot_bapa/(rpa*rab)
    cosb = dot_pbab/(rpb*rab)
    arg1(:) = b - p
    arg2(:) = a - p
    CALL CROSSC(arg1(:), arg2(:), c)
    CALL UNITC(c, c)
    IF (inf) THEN
      tmp = -(c/rh*(cosa+1))
    ELSE
      tmp = -(c/rh*(cosa+cosb))
    END IF
    IF (rev) tmp = -tmp
    out = out + tmp
  END SUBROUTINE BIOTSAVART
! COMPLEX FUNCTIONS
  SUBROUTINE UNITC(v, u)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: v(3)
    COMPLEX(kind=8), INTENT(OUT) :: u(3)
    COMPLEX(kind=8) :: nm
    CALL NORMC(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  END SUBROUTINE UNITC
!  Differentiation of normc in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: v norm_output
!   with respect to varying inputs: v
  SUBROUTINE NORMC_B(v, vb, norm_output, norm_outputb)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: v(3)
    COMPLEX(kind=8) :: vb(3)
    COMPLEX(kind=8) :: norm_output
    COMPLEX(kind=8) :: norm_outputb
    COMPLEX(kind=8) :: dot_prod
    COMPLEX(kind=8) :: dot_prodb
!norm = sqrt(dot_product(v, v))
    CALL DOTC(v, v, dot_prod)
    dot_prodb = 0.5*dot_prod**(-0.5)*norm_outputb
    CALL DOTC_B(v, vb, v, vb, dot_prod, dot_prodb)
  END SUBROUTINE NORMC_B
  SUBROUTINE NORMC(v, norm_output)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: v(3)
    COMPLEX(kind=8), INTENT(OUT) :: norm_output
    COMPLEX(kind=8) :: dot_prod
!norm = sqrt(dot_product(v, v))
    CALL DOTC(v, v, dot_prod)
    norm_output = dot_prod**0.5
  END SUBROUTINE NORMC
!  Differentiation of dotc in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: dot_prod a b
!   with respect to varying inputs: a b
  SUBROUTINE DOTC_B(a, ab, b, bb, dot_prod, dot_prodb)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3)
    COMPLEX(kind=8) :: ab(3), bb(3)
    COMPLEX(kind=8) :: dot_prod
    COMPLEX(kind=8) :: dot_prodb
    ab(1) = ab(1) + b(1)*dot_prodb
    bb(1) = bb(1) + a(1)*dot_prodb
    ab(2) = ab(2) + b(2)*dot_prodb
    bb(2) = bb(2) + a(2)*dot_prodb
    ab(3) = ab(3) + b(3)*dot_prodb
    bb(3) = bb(3) + a(3)*dot_prodb
  END SUBROUTINE DOTC_B
  SUBROUTINE DOTC(a, b, dot_prod)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3)
    COMPLEX(kind=8), INTENT(OUT) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  END SUBROUTINE DOTC
!  Differentiation of crossc in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b c
  SUBROUTINE CROSSC_B(a, ab, b, bb, c, cb)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3)
    COMPLEX(kind=8) :: ab(3), bb(3)
    COMPLEX(kind=8) :: c(3)
    COMPLEX(kind=8) :: cb(3)
    ab(1) = ab(1) + b(2)*cb(3)
    bb(2) = bb(2) + a(1)*cb(3)
    ab(2) = ab(2) - b(1)*cb(3)
    bb(1) = bb(1) - a(2)*cb(3)
    cb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*cb(2)
    bb(1) = bb(1) + a(3)*cb(2)
    ab(1) = ab(1) - b(3)*cb(2)
    bb(3) = bb(3) - a(1)*cb(2)
    cb(2) = 0.0_8
    ab(2) = ab(2) + b(3)*cb(1)
    bb(3) = bb(3) + a(2)*cb(1)
    ab(3) = ab(3) - b(2)*cb(1)
    bb(2) = bb(2) - a(3)*cb(1)
    cb(1) = 0.0_8
  END SUBROUTINE CROSSC_B
  SUBROUTINE CROSSC(a, b, c)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3)
    COMPLEX(kind=8), INTENT(OUT) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSSC
!  Differentiation of unit in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
! REAL FUNCTIONS
  SUBROUTINE UNIT_B(v, vb, u, ub)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: v(3)
    REAL(kind=8) :: vb(3)
    REAL(kind=8) :: u(3)
    REAL(kind=8) :: ub(3)
    REAL(kind=8) :: nm
    REAL(kind=8) :: nmb
    CALL NORM(v, nm)
    vb(3) = vb(3) + ub(3)/nm
    nmb = -(v(3)*ub(3)/nm**2)
    ub(3) = 0.0_8
    vb(2) = vb(2) + ub(2)/nm
    nmb = nmb - v(2)*ub(2)/nm**2
    ub(2) = 0.0_8
    vb(1) = vb(1) + ub(1)/nm
    nmb = nmb - v(1)*ub(1)/nm**2
    ub(1) = 0.0_8
    CALL NORM_B(v, vb, nm, nmb)
  END SUBROUTINE UNIT_B
! REAL FUNCTIONS
  SUBROUTINE UNIT(v, u)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: v(3)
    REAL(kind=8), INTENT(OUT) :: u(3)
    REAL(kind=8) :: nm
    CALL NORM(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  END SUBROUTINE UNIT
!  Differentiation of norm in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: v norm_output
!   with respect to varying inputs: v
  SUBROUTINE NORM_B(v, vb, norm_output, norm_outputb)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: v(3)
    REAL(kind=8) :: vb(3)
    REAL(kind=8) :: norm_output
    REAL(kind=8) :: norm_outputb
    REAL(kind=8) :: dot_prod
    REAL(kind=8) :: dot_prodb
!norm = sqrt(dot_product(v, v))
    CALL DOT(v, v, dot_prod)
    dot_prodb = 0.5*dot_prod**(-0.5)*norm_outputb
    CALL DOT_B(v, vb, v, vb, dot_prod, dot_prodb)
  END SUBROUTINE NORM_B
  SUBROUTINE NORM(v, norm_output)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: v(3)
    REAL(kind=8), INTENT(OUT) :: norm_output
    REAL(kind=8) :: dot_prod
!norm = sqrt(dot_product(v, v))
    CALL DOT(v, v, dot_prod)
    norm_output = dot_prod**0.5
  END SUBROUTINE NORM
!  Differentiation of dot in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: dot_prod a b
!   with respect to varying inputs: a b
  SUBROUTINE DOT_B(a, ab, b, bb, dot_prod, dot_prodb)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: a(3), b(3)
    REAL(kind=8) :: ab(3), bb(3)
    REAL(kind=8) :: dot_prod
    REAL(kind=8) :: dot_prodb
    ab(1) = ab(1) + b(1)*dot_prodb
    bb(1) = bb(1) + a(1)*dot_prodb
    ab(2) = ab(2) + b(2)*dot_prodb
    bb(2) = bb(2) + a(2)*dot_prodb
    ab(3) = ab(3) + b(3)*dot_prodb
    bb(3) = bb(3) + a(3)*dot_prodb
  END SUBROUTINE DOT_B
  SUBROUTINE DOT(a, b, dot_prod)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: a(3), b(3)
    REAL(kind=8), INTENT(OUT) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  END SUBROUTINE DOT
!  Differentiation of cross in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b c
  SUBROUTINE CROSS_B(a, ab, b, bb, c, cb)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: a(3), b(3)
    REAL(kind=8) :: ab(3), bb(3)
    REAL(kind=8) :: c(3)
    REAL(kind=8) :: cb(3)
    ab(1) = ab(1) + b(2)*cb(3)
    bb(2) = bb(2) + a(1)*cb(3)
    ab(2) = ab(2) - b(1)*cb(3)
    bb(1) = bb(1) - a(2)*cb(3)
    cb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*cb(2)
    bb(1) = bb(1) + a(3)*cb(2)
    ab(1) = ab(1) - b(3)*cb(2)
    bb(3) = bb(3) - a(1)*cb(2)
    cb(2) = 0.0_8
    ab(2) = ab(2) + b(3)*cb(1)
    bb(3) = bb(3) + a(2)*cb(1)
    ab(3) = ab(3) - b(2)*cb(1)
    bb(2) = bb(2) - a(3)*cb(1)
    cb(1) = 0.0_8
  END SUBROUTINE CROSS_B
  SUBROUTINE CROSS(a, b, c)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: a(3), b(3)
    REAL(kind=8), INTENT(OUT) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS
END MODULE OAS_MAIN_B
