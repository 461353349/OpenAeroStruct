!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module oas_main_d
  implicit none

contains
!  differentiation of mult_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: y
!   with respect to varying inputs: x
!   rw status of diff variables: x:in y:out
  subroutine mult_main_d(nx, ny, x, xd, y, yd)
    implicit none
    integer, intent(in) :: nx, ny
    real*8, intent(in) :: x(nx)
    real*8, intent(in) :: xd(nx)
    real*8, intent(out) :: y(ny)
    real*8, intent(out) :: yd(ny)
    integer :: i, j
    y(:) = 0.
    yd = 0.0_8
    do j=1,ny
      do i=1,nx
        yd(j) = yd(j) + 2*x(i)*xd(i)
        y(j) = y(j) + x(i)**2 + j
      end do
    end do
  end subroutine mult_main_d
  subroutine mult_main(nx, ny, x, y)
    implicit none
    integer, intent(in) :: nx, ny
    real*8, intent(in) :: x(nx)
    real*8, intent(out) :: y(ny)
    integer :: i, j
    y(:) = 0.
    do j=1,ny
      do i=1,nx
        y(j) = y(j) + x(i)**2 + j
      end do
    end do
  end subroutine mult_main
!  differentiation of calc_vonmises_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: vonmises
!   with respect to varying inputs: r nodes disp
!   rw status of diff variables: r:in vonmises:out nodes:in disp:in
  subroutine calc_vonmises_main_d(elem_ids, nodes, nodesd, r, rd, disp, &
&   dispd, e, g, x_gl, num_elems, n, vonmises, vonmisesd)
    implicit none
! input
    integer, intent(in) :: elem_ids(num_elems, 2), num_elems, n
    complex(kind=8), intent(in) :: nodes(n, 3), r(num_elems), disp(n, 6)
    complex(kind=8), intent(in) :: nodesd(n, 3), rd(num_elems), dispd(n&
&   , 6)
    complex(kind=8), intent(in) :: e, g, x_gl(3)
    complex(kind=8) :: x_gld(3)
! output
    complex(kind=8), intent(out) :: vonmises(num_elems, 2)
    complex(kind=8), intent(out) :: vonmisesd(num_elems, 2)
! working
    integer :: ielem, in0, in1
    complex(kind=8) :: p0(3), p1(3), l, x_loc(3), y_loc(3), z_loc(3), t(&
&   3, 3)
    complex(kind=8) :: p0d(3), p1d(3), ld, x_locd(3), y_locd(3), z_locd(&
&   3), td(3, 3)
    complex(kind=8) :: u0(3), r0(3), u1(3), r1(3), sxx0, sxx1, sxt, tmp
    complex(kind=8) :: u0d(3), r0d(3), u1d(3), r1d(3), sxx0d, sxx1d, &
&   sxtd, tmpd
    vonmisesd = (0.0_4,0.0_4)
    y_locd = (0.0_4,0.0_4)
    td = (0.0_4,0.0_4)
    z_locd = (0.0_4,0.0_4)
    x_locd = (0.0_4,0.0_4)
    do ielem=1,num_elems
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      p0d = nodesd(in0, :)
      p0 = nodes(in0, :)
      p1d = nodesd(in1, :)
      p1 = nodes(in1, :)
      call normc_d(p1 - p0, p1d - p0d, l, ld)
      call unitc_d(p1 - p0, p1d - p0d, x_loc, x_locd)
      x_gld = (0.0_4,0.0_4)
      call crossc_d(x_loc, x_locd, x_gl, x_gld, y_loc, y_locd)
      call unitc_d(y_loc, y_locd, y_loc, y_locd)
      call crossc_d(x_loc, x_locd, y_loc, y_locd, z_loc, z_locd)
      call unitc_d(z_loc, z_locd, z_loc, z_locd)
      td(1, :) = x_locd
      t(1, :) = x_loc
      td(2, :) = y_locd
      t(2, :) = y_loc
      td(3, :) = z_locd
      t(3, :) = z_loc
      call matmul2c_d(3, 3, 1, t, td, disp(in0, :3), dispd(in0, :3), u0&
&               , u0d)
      call matmul2c_d(3, 3, 1, t, td, disp(in0, 4:), dispd(in0, 4:), r0&
&               , r0d)
      call matmul2c_d(3, 3, 1, t, td, disp(in1, :3), dispd(in1, :3), u1&
&               , u1d)
      call matmul2c_d(3, 3, 1, t, td, disp(in1, 4:), dispd(in1, 4:), r1&
&               , r1d)
      tmpd = .5*((r1(2)-r0(2))**2+(r1(3)-r0(3))**2)**(-0.5)*(2*(r1(2)-r0&
&       (2))*(r1d(2)-r0d(2))+2*(r1(3)-r0(3))*(r1d(3)-r0d(3)))
      tmp = ((r1(2)-r0(2))**2+(r1(3)-r0(3))**2)**.5
      sxx0d = (e*(u1d(1)-u0d(1))*l-e*(u1(1)-u0(1))*ld)/l**2 + (e*rd(&
&       ielem)*l-e*r(ielem)*ld)*tmp/l**2 + e*r(ielem)*tmpd/l
      sxx0 = e*(u1(1)-u0(1))/l + e*r(ielem)/l*tmp
      sxx1d = (e*(u0d(1)-u1d(1))*l-e*(u0(1)-u1(1))*ld)/l**2 + (e*rd(&
&       ielem)*l-e*r(ielem)*ld)*tmp/l**2 + e*r(ielem)*tmpd/l
      sxx1 = e*(u0(1)-u1(1))/l + e*r(ielem)/l*tmp
      sxtd = (g*(rd(ielem)*(r1(1)-r0(1))+r(ielem)*(r1d(1)-r0d(1)))*l-g*r&
&       (ielem)*(r1(1)-r0(1))*ld)/l**2
      sxt = g*r(ielem)*(r1(1)-r0(1))/l
      vonmisesd(ielem, 1) = .5*(sxx0**2+sxt**2)**(-0.5)*(2*sxx0*sxx0d+2*&
&       sxt*sxtd)
      vonmises(ielem, 1) = (sxx0**2+sxt**2)**.5
      vonmisesd(ielem, 2) = .5*(sxx1**2+sxt**2)**(-0.5)*(2*sxx1*sxx1d+2*&
&       sxt*sxtd)
      vonmises(ielem, 2) = (sxx1**2+sxt**2)**.5
    end do
  end subroutine calc_vonmises_main_d
  subroutine calc_vonmises_main(elem_ids, nodes, r, disp, e, g, x_gl, &
&   num_elems, n, vonmises)
    implicit none
! input
    integer, intent(in) :: elem_ids(num_elems, 2), num_elems, n
    complex(kind=8), intent(in) :: nodes(n, 3), r(num_elems), disp(n, 6)
    complex(kind=8), intent(in) :: e, g, x_gl(3)
! output
    complex(kind=8), intent(out) :: vonmises(num_elems, 2)
! working
    integer :: ielem, in0, in1
    complex(kind=8) :: p0(3), p1(3), l, x_loc(3), y_loc(3), z_loc(3), t(&
&   3, 3)
    complex(kind=8) :: u0(3), r0(3), u1(3), r1(3), sxx0, sxx1, sxt, tmp
    do ielem=1,num_elems
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      p0 = nodes(in0, :)
      p1 = nodes(in1, :)
      call normc(p1 - p0, l)
      call unitc(p1 - p0, x_loc)
      call crossc(x_loc, x_gl, y_loc)
      call unitc(y_loc, y_loc)
      call crossc(x_loc, y_loc, z_loc)
      call unitc(z_loc, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      call matmul2c(3, 3, 1, t, disp(in0, :3), u0)
      call matmul2c(3, 3, 1, t, disp(in0, 4:), r0)
      call matmul2c(3, 3, 1, t, disp(in1, :3), u1)
      call matmul2c(3, 3, 1, t, disp(in1, 4:), r1)
      tmp = ((r1(2)-r0(2))**2+(r1(3)-r0(3))**2)**.5
      sxx0 = e*(u1(1)-u0(1))/l + e*r(ielem)/l*tmp
      sxx1 = e*(u0(1)-u1(1))/l + e*r(ielem)/l*tmp
      sxt = g*r(ielem)*(r1(1)-r0(1))/l
      vonmises(ielem, 1) = (sxx0**2+sxt**2)**.5
      vonmises(ielem, 2) = (sxx1**2+sxt**2)**.5
    end do
  end subroutine calc_vonmises_main
!  differentiation of transferdisplacements_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: def_mesh
!   with respect to varying inputs: mesh disp
!   rw status of diff variables: mesh:in def_mesh:out disp:in
  subroutine transferdisplacements_main_d(nx, ny, mesh, meshd, disp, &
&   dispd, w, def_mesh, def_meshd)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3), disp(ny, 6), w
    real(kind=8), intent(in) :: meshd(nx, ny, 3), dispd(ny, 6)
! output
    real(kind=8), intent(out) :: def_mesh(nx, ny, 3)
    real(kind=8), intent(out) :: def_meshd(nx, ny, 3)
! working
    integer :: ind, indx
    real(kind=8) :: smesh(nx, ny, 3), t(3, 3), t_base(3, 3), vec(3)
    real(kind=8) :: smeshd(nx, ny, 3), td(3, 3), vecd(3)
    real(kind=8) :: sinr(3), cosr(3), r(3), ref_curve(ny, 3)
    real(kind=8) :: sinrd(3), cosrd(3), rd(3), ref_curved(ny, 3)
    intrinsic cos
    intrinsic sin
    ref_curved = (1-w)*meshd(1, :, :) + w*meshd(nx, :, :)
    ref_curve = (1-w)*mesh(1, :, :) + w*mesh(nx, :, :)
    def_mesh(:, :, :) = 0.
    t_base(:, :) = 0.
    do ind=1,3
      t_base(ind, ind) = -2.
    end do
    smeshd = 0.0_8
    do ind=1,nx
      smeshd(ind, :, :) = meshd(ind, :, :) - ref_curved
      smesh(ind, :, :) = mesh(ind, :, :) - ref_curve
    end do
    def_meshd = 0.0_8
    do ind=1,ny
      rd = dispd(ind, 4:6)
      r = disp(ind, 4:6)
      cosrd = -(rd*sin(r))
      cosr = cos(r)
      sinrd = rd*cos(r)
      sinr = sin(r)
      t(:, :) = 0.
      td = 0.0_8
      td(1, 1) = cosrd(3) + cosrd(2)
      t(1, 1) = cosr(3) + cosr(2)
      td(2, 2) = cosrd(3) + cosrd(1)
      t(2, 2) = cosr(3) + cosr(1)
      td(3, 3) = cosrd(1) + cosrd(2)
      t(3, 3) = cosr(1) + cosr(2)
      td(1, 2) = -sinrd(3)
      t(1, 2) = -sinr(3)
      td(1, 3) = sinrd(2)
      t(1, 3) = sinr(2)
      td(2, 1) = sinrd(3)
      t(2, 1) = sinr(3)
      td(2, 3) = -sinrd(1)
      t(2, 3) = -sinr(1)
      td(3, 1) = -sinrd(2)
      t(3, 1) = -sinr(2)
      td(3, 2) = sinrd(1)
      t(3, 2) = sinr(1)
      t = t + t_base
      do indx=1,nx
        call matmul2_d(1, 3, 3, smesh(indx, ind, :), smeshd(indx, ind, :&
&                ), t, td, vec, vecd)
        def_meshd(indx, ind, :) = def_meshd(indx, ind, :) + vecd
        def_mesh(indx, ind, :) = def_mesh(indx, ind, :) + vec
      end do
      def_meshd(:, ind, 1) = def_meshd(:, ind, 1) + dispd(ind, 1)
      def_mesh(:, ind, 1) = def_mesh(:, ind, 1) + disp(ind, 1)
      def_meshd(:, ind, 2) = def_meshd(:, ind, 2) + dispd(ind, 2)
      def_mesh(:, ind, 2) = def_mesh(:, ind, 2) + disp(ind, 2)
      def_meshd(:, ind, 3) = def_meshd(:, ind, 3) + dispd(ind, 3)
      def_mesh(:, ind, 3) = def_mesh(:, ind, 3) + disp(ind, 3)
    end do
    def_meshd = def_meshd + meshd
    def_mesh = def_mesh + mesh
  end subroutine transferdisplacements_main_d
  subroutine transferdisplacements_main(nx, ny, mesh, disp, w, def_mesh)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3), disp(ny, 6), w
! output
    real(kind=8), intent(out) :: def_mesh(nx, ny, 3)
! working
    integer :: ind, indx
    real(kind=8) :: smesh(nx, ny, 3), t(3, 3), t_base(3, 3), vec(3)
    real(kind=8) :: sinr(3), cosr(3), r(3), ref_curve(ny, 3)
    intrinsic cos
    intrinsic sin
    ref_curve = (1-w)*mesh(1, :, :) + w*mesh(nx, :, :)
    def_mesh(:, :, :) = 0.
    t_base(:, :) = 0.
    do ind=1,3
      t_base(ind, ind) = -2.
    end do
    do ind=1,nx
      smesh(ind, :, :) = mesh(ind, :, :) - ref_curve
    end do
    do ind=1,ny
      r = disp(ind, 4:6)
      cosr = cos(r)
      sinr = sin(r)
      t(:, :) = 0.
      t(1, 1) = cosr(3) + cosr(2)
      t(2, 2) = cosr(3) + cosr(1)
      t(3, 3) = cosr(1) + cosr(2)
      t(1, 2) = -sinr(3)
      t(1, 3) = sinr(2)
      t(2, 1) = sinr(3)
      t(2, 3) = -sinr(1)
      t(3, 1) = -sinr(2)
      t(3, 2) = sinr(1)
      t = t + t_base
      do indx=1,nx
        call matmul2(1, 3, 3, smesh(indx, ind, :), t, vec)
        def_mesh(indx, ind, :) = def_mesh(indx, ind, :) + vec
      end do
      def_mesh(:, ind, 1) = def_mesh(:, ind, 1) + disp(ind, 1)
      def_mesh(:, ind, 2) = def_mesh(:, ind, 2) + disp(ind, 2)
      def_mesh(:, ind, 3) = def_mesh(:, ind, 3) + disp(ind, 3)
    end do
    def_mesh = def_mesh + mesh
  end subroutine transferdisplacements_main
!  differentiation of assemblestructmtx_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: x
!   with respect to varying inputs: j nodes iy iz rhs a
!   rw status of diff variables: j:in k:(loc) x:out nodes:in iy:in
!                iz:in rhs:in a:in
! 6
! 4
! 3
! 3
! 6
  subroutine assemblestructmtx_main_d(n, tot_n_fem, size, nodes, nodesd&
&   , a, ad, j, jd, iy, iyd, iz, izd, k_a, k_t, k_y, k_z, elem_ids, cons&
&   , e, g, x_gl, t, k_elem, pelem_a, pelem_t, pelem_y, pelem_z, t_elem&
&   , const2, const_y, const_z, rhs, rhsd, k, kd, x, xd)
! 7
    use solveroutines, only : solve_d
    implicit none
! input
    integer, intent(in) :: n, size, cons, tot_n_fem
    integer, intent(inout) :: elem_ids(n-1, 2)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8), intent(in) :: nodesd(tot_n_fem, 3), ad(n-1), jd(n-1), &
&   iyd(n-1), izd(n-1)
    real(kind=8), intent(in) :: e(n-1), g(n-1), x_gl(3)
    real(kind=8) :: x_gld(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8) :: k_ad(2, 2)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8) :: td(3, 3)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8) :: pelem_ad(2, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4), rhs(size)
    real(kind=8), intent(in) :: rhsd(size)
! output
    real(kind=8), intent(out) :: x(size), k(size, size)
    real(kind=8), intent(out) :: xd(size), kd(size, size)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: p0d(3), p1d(3), x_locd(3), y_locd(3), z_locd(3), &
&   x_crossd(3), y_crossd(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: ld, ea_ld, gj_ld, eiy_l3d, eiz_l3d, resd(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    real(kind=8) :: mat12x12d(12, 12), mat12x4d(12, 4), mat12x2d(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(size, size)
    real(kind=8) :: pelem_a_td(12, 2), pelem_t_td(12, 2), k_d(size, size&
&   )
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)&
&   , b(size)
    real(kind=8) :: pelem_y_td(12, 4), pelem_z_td(12, 4), t_elem_td(12, &
&   12), bd(size)
    integer :: ipiv(size), n_solve
    real(kind=8) :: pelem_zd(4, 12)
    real(kind=8) :: k_elemd(12, 12)
    real(kind=8) :: k_yd(4, 4)
    real(kind=8) :: pelem_yd(4, 12)
    real(kind=8) :: t_elemd(12, 12)
    real(kind=8) :: k_td(2, 2)
    real(kind=8) :: k_zd(4, 4)
    real(kind=8) :: pelem_td(2, 12)
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    k(:, :) = 0.
    kd = 0.0_8
    td = 0.0_8
    t_elemd = 0.0_8
    y_locd = 0.0_8
    z_locd = 0.0_8
    t_elem_td = 0.0_8
    y_crossd = 0.0_8
    x_crossd = 0.0_8
    x_locd = 0.0_8
! loop over num elements
    do ielem=1,num_elems
      p0d = nodesd(elem_ids(ielem, 1), :)
      p0 = nodes(elem_ids(ielem, 1), :)
      p1d = nodesd(elem_ids(ielem, 2), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      call unit_d(p1 - p0, p1d - p0d, x_loc, x_locd)
      x_gld = 0.0_8
      call cross_d(x_loc, x_locd, x_gl, x_gld, x_cross, x_crossd)
      call unit_d(x_cross, x_crossd, y_loc, y_locd)
      call cross_d(x_loc, x_locd, y_loc, y_locd, y_cross, y_crossd)
      call unit_d(y_cross, y_crossd, z_loc, z_locd)
      td(1, :) = x_locd
      t(1, :) = x_loc
      td(2, :) = y_locd
      t(2, :) = y_loc
      td(3, :) = z_locd
      t(3, :) = z_loc
      do ind=1,4
        t_elemd(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = td
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      call norm_d(p1 - p0, p1d - p0d, l, ld)
      ea_ld = (e(ielem)*ad(ielem)*l-e(ielem)*a(ielem)*ld)/l**2
      ea_l = e(ielem)*a(ielem)/l
      gj_ld = (g(ielem)*jd(ielem)*l-g(ielem)*j(ielem)*ld)/l**2
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3d = (e(ielem)*iyd(ielem)*l**3-e(ielem)*iy(ielem)*3*l**2*ld)/&
&       (l**3)**2
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3d = (e(ielem)*izd(ielem)*l**3-e(ielem)*iz(ielem)*3*l**2*ld)/&
&       (l**3)**2
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_ad(:, :) = const2*ea_ld
      k_a(:, :) = ea_l*const2
      k_td(:, :) = const2*gj_ld
      k_t(:, :) = gj_l*const2
      k_yd(:, :) = const_y*eiy_l3d
      k_y(:, :) = eiy_l3*const_y
      k_yd(2, :) = k_yd(2, :)*l + k_y(2, :)*ld
      k_y(2, :) = k_y(2, :)*l
      k_yd(4, :) = k_yd(4, :)*l + k_y(4, :)*ld
      k_y(4, :) = k_y(4, :)*l
      k_yd(:, 2) = k_yd(:, 2)*l + k_y(:, 2)*ld
      k_y(:, 2) = k_y(:, 2)*l
      k_yd(:, 4) = k_yd(:, 4)*l + k_y(:, 4)*ld
      k_y(:, 4) = k_y(:, 4)*l
      k_zd(:, :) = const_z*eiz_l3d
      k_z(:, :) = eiz_l3*const_z
      k_zd(2, :) = k_zd(2, :)*l + k_z(2, :)*ld
      k_z(2, :) = k_z(2, :)*l
      k_zd(4, :) = k_zd(4, :)*l + k_z(4, :)*ld
      k_z(4, :) = k_z(4, :)*l
      k_zd(:, 2) = k_zd(:, 2)*l + k_z(:, 2)*ld
      k_z(:, 2) = k_z(:, 2)*l
      k_zd(:, 4) = k_zd(:, 4)*l + k_z(:, 4)*ld
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      pelem_a_td = 0.0_8
      call matmul2_d(12, 2, 2, pelem_a_t, pelem_a_td, k_a, k_ad, mat12x2&
&              , mat12x2d)
      pelem_ad = 0.0_8
      call matmul2_d(12, 2, 12, mat12x2, mat12x2d, pelem_a, pelem_ad, &
&              res, resd)
      k_elemd = resd
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      pelem_t_td = 0.0_8
      call matmul2_d(12, 2, 2, pelem_t_t, pelem_t_td, k_t, k_td, mat12x2&
&              , mat12x2d)
      pelem_td = 0.0_8
      call matmul2_d(12, 2, 12, mat12x2, mat12x2d, pelem_t, pelem_td, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      pelem_y_td = 0.0_8
      call matmul2_d(12, 4, 4, pelem_y_t, pelem_y_td, k_y, k_yd, mat12x4&
&              , mat12x4d)
      pelem_yd = 0.0_8
      call matmul2_d(12, 4, 12, mat12x4, mat12x4d, pelem_y, pelem_yd, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      pelem_z_td = 0.0_8
      call matmul2_d(12, 4, 4, pelem_z_t, pelem_z_td, k_z, k_zd, mat12x4&
&              , mat12x4d)
      pelem_zd = 0.0_8
      call matmul2_d(12, 4, 12, mat12x4, mat12x4d, pelem_z, pelem_zd, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2_d(12, 12, t_elem, t_elemd, t_elem_t, t_elem_td)
      call matmul2_d(12, 12, 12, t_elem_t, t_elem_td, k_elem, k_elemd, &
&              mat12x12, mat12x12d)
      call matmul2_d(12, 12, 12, mat12x12, mat12x12d, t_elem, t_elemd, &
&              res, resd)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      kd(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = kd(6*(in0-1&
&       )+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + resd(:6, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      kd(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = kd(6*(in1-1&
&       )+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + resd(7:, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      kd(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = kd(6*(in0-1&
&       )+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + resd(:6, 7:)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      kd(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = kd(6*(in1-1&
&       )+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + resd(7:, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      kd(6*num_nodes+i, 6*cons+i) = 0.0_8
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      kd(6*cons+i, 6*num_nodes+i) = 0.0_8
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
    n_solve = size
    bd = rhsd
    b = rhs
    k_d = kd
    k_ = k
    xd = 0.0_8
    call solve_d(k_, k_d, x, xd, b, bd, n_solve, ipiv)
  end subroutine assemblestructmtx_main_d
! 6
! 4
! 3
! 3
! 6
  subroutine assemblestructmtx_main(n, tot_n_fem, size, nodes, a, j, iy&
&   , iz, k_a, k_t, k_y, k_z, elem_ids, cons, e, g, x_gl, t, k_elem, &
&   pelem_a, pelem_t, pelem_y, pelem_z, t_elem, const2, const_y, const_z&
&   , rhs, k, x)
! 7
    use solveroutines, only : solve
    implicit none
! input
    integer, intent(in) :: n, size, cons, tot_n_fem
    integer, intent(inout) :: elem_ids(n-1, 2)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8), intent(in) :: e(n-1), g(n-1), x_gl(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4), rhs(size)
! output
    real(kind=8), intent(out) :: x(size), k(size, size)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(size, size)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)&
&   , b(size)
    integer :: ipiv(size), n_solve
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    k(:, :) = 0.
! loop over num elements
    do ielem=1,num_elems
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      call unit(p1 - p0, x_loc)
      call cross(x_loc, x_gl, x_cross)
      call unit(x_cross, y_loc)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do ind=1,4
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      call norm(p1 - p0, l)
      ea_l = e(ielem)*a(ielem)/l
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      k_y(:, :) = eiy_l3*const_y
      k_y(2, :) = k_y(2, :)*l
      k_y(4, :) = k_y(4, :)*l
      k_y(:, 2) = k_y(:, 2)*l
      k_y(:, 4) = k_y(:, 4)*l
      k_z(:, :) = eiz_l3*const_z
      k_z(2, :) = k_z(2, :)*l
      k_z(4, :) = k_z(4, :)*l
      k_z(:, 2) = k_z(:, 2)*l
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call matmul2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call matmul2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call matmul2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call matmul2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call transpose2(12, 12, t_elem, t_elem_t)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      call matmul2(12, 12, 12, mat12x12, t_elem, res)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
    n_solve = size
    b = rhs
    k_ = k
    call solve(k_, x, b, n_solve, ipiv)
  end subroutine assemblestructmtx_main
!  differentiation of transpose2 in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: new_mtx
!   with respect to varying inputs: new_mtx mtx
  subroutine transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8), intent(in) :: mtxd(m, n)
    real(kind=8), intent(out) :: new_mtx(n, m)
    real(kind=8), intent(out) :: new_mtxd(n, m)
    integer :: i, j
    do i=1,m
      do j=1,n
        new_mtxd(j, i) = mtxd(i, j)
        new_mtx(j, i) = mtx(i, j)
      end do
    end do
  end subroutine transpose2_d
  subroutine transpose2(m, n, mtx, new_mtx)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8), intent(out) :: new_mtx(n, m)
    integer :: i, j
    do i=1,m
      do j=1,n
        new_mtx(j, i) = mtx(i, j)
      end do
    end do
  end subroutine transpose2
!  differentiation of matmul2 in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: c
!   with respect to varying inputs: a b
  subroutine matmul2_d(m, n, p, a, ad, b, bd, c, cd)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8), intent(in) :: ad(m, n), bd(n, p)
    real(kind=8), intent(out) :: c(m, p)
    real(kind=8), intent(out) :: cd(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    cd = 0.0_8
    do i=1,m
      do j=1,p
        do k=1,n
          cd(i, j) = cd(i, j) + ad(i, k)*b(k, j) + a(i, k)*bd(k, j)
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2_d
  subroutine matmul2(m, n, p, a, b, c)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8), intent(out) :: c(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    do i=1,m
      do j=1,p
        do k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2
!  differentiation of matmul2c in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: c
!   with respect to varying inputs: a b
  subroutine matmul2c_d(m, n, p, a, ad, b, bd, c, cd)
    implicit none
    integer, intent(in) :: m, n, p
    complex(kind=8), intent(in) :: a(m, n), b(n, p)
    complex(kind=8), intent(in) :: ad(m, n), bd(n, p)
    complex(kind=8), intent(out) :: c(m, p)
    complex(kind=8), intent(out) :: cd(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    cd = (0.0_4,0.0_4)
    do i=1,m
      do j=1,p
        do k=1,n
          cd(i, j) = cd(i, j) + ad(i, k)*b(k, j) + a(i, k)*bd(k, j)
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2c_d
  subroutine matmul2c(m, n, p, a, b, c)
    implicit none
    integer, intent(in) :: m, n, p
    complex(kind=8), intent(in) :: a(m, n), b(n, p)
    complex(kind=8), intent(out) :: c(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    do i=1,m
      do j=1,p
        do k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2c
!  differentiation of assembleaeromtx_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: mtx
!   with respect to varying inputs: alpha points mesh bpts
!   rw status of diff variables: alpha:in points:in mesh:in bpts:in
!                mtx:out
  subroutine assembleaeromtx_main_d(ny, nx, ny_, nx_, alpha, alphad, &
&   points, pointsd, bpts, bptsd, mesh, meshd, skip, symmetry, mtx, mtxd&
& )
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    complex(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    complex(kind=8), intent(in) :: alphad, meshd(nx_, ny_, 3)
    complex(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, &
&   ny_, 3)
    complex(kind=8), intent(in) :: pointsd(nx-1, ny-1, 3), bptsd(nx_-1, &
&   ny_, 3)
    logical, intent(in) :: skip, symmetry
! output
    complex(kind=8), intent(out) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), &
&   3)
    complex(kind=8), intent(out) :: mtxd((nx-1)*(ny-1), (nx_-1)*(ny_-1)&
&   , 3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    complex(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    complex(kind=8) :: pd(3), ad(3), bd(3), ud(3), cd(3), dd(3)
    complex(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    complex(kind=8) :: a_symd(3), b_symd(3), c_symd(3), d_symd(3)
    complex(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    complex(kind=8) :: ur2d(3), r1d(3), r2d(3), r1_magd, r2_magd
    complex(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    complex(kind=8) :: ur1d(3), boundd(3), dot_ur2d, dot_ur1d
    complex(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym&
&   (3)
    complex(kind=8) :: edgesd(3), c_ted(3), d_ted(3), c_te_symd(3), &
&   d_te_symd(3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
    ud = (0.0_4,0.0_4)
    ud(1) = -(pi*alphad*sin(alpha*pi/180.)/180.)
    u(1) = cos(alpha*pi/180.)
    ud(2) = 0.0_8
    u(2) = 0.
    ud(3) = pi*alphad*cos(alpha*pi/180.)/180.
    u(3) = sin(alpha*pi/180.)
    mtx(:, :, :) = 0.
    mtxd = (0.0_4,0.0_4)
    ur1d = (0.0_4,0.0_4)
    ur2d = (0.0_4,0.0_4)
    a_symd = (0.0_4,0.0_4)
    c_te_symd = (0.0_4,0.0_4)
    b_symd = (0.0_4,0.0_4)
    d_te_symd = (0.0_4,0.0_4)
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_ted = meshd(nx_, el_j+1, :)
      c_te = mesh(nx_, el_j+1, :)
      d_ted = meshd(nx_, el_j+0, :)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_symd = c_ted
        c_te_sym = c_te
        d_te_symd = d_ted
        d_te_sym = d_te
        c_te_symd(2) = -c_te_symd(2)
        c_te_sym(2) = -c_te_sym(2)
        d_te_symd(2) = -d_te_symd(2)
        d_te_sym(2) = -d_te_sym(2)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          pd = pointsd(cp_i, cp_j, :)
          p = points(cp_i, cp_j, :)
          r1d = pd - d_ted
          r1 = p - d_te
          r2d = pd - c_ted
          r2 = p - c_te
          call normc_d(r1, r1d, r1_mag, r1_magd)
          call normc_d(r2, r2d, r2_mag, r2_magd)
          call crossc_d(u, ud, r2, r2d, ur2, ur2d)
          call crossc_d(u, ud, r1, r1d, ur1, ur1d)
          edges(:) = 0.
          call dotc_d(u, ud, r2, r2d, dot_ur2, dot_ur2d)
          call dotc_d(u, ud, r1, r1d, dot_ur1, dot_ur1d)
          edgesd = (ur2d*r2_mag*(r2_mag-dot_ur2)-ur2*(r2_magd*(r2_mag-&
&           dot_ur2)+r2_mag*(r2_magd-dot_ur2d)))/(r2_mag*(r2_mag-dot_ur2&
&           ))**2
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edgesd = edgesd - (ur1d*r1_mag*(r1_mag-dot_ur1)-ur1*(r1_magd*(&
&           r1_mag-dot_ur1)+r1_mag*(r1_magd-dot_ur1d)))/(r1_mag*(r1_mag-&
&           dot_ur1))**2
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          if (symmetry) then
            r1d = pd - d_te_symd
            r1 = p - d_te_sym
            r2d = pd - c_te_symd
            r2 = p - c_te_sym
            call normc_d(r1, r1d, r1_mag, r1_magd)
            call normc_d(r2, r2d, r2_mag, r2_magd)
            call crossc_d(u, ud, r2, r2d, ur2, ur2d)
            call crossc_d(u, ud, r1, r1d, ur1, ur1d)
            call dotc_d(u, ud, r2, r2d, dot_ur2, dot_ur2d)
            call dotc_d(u, ud, r1, r1d, dot_ur1, dot_ur1d)
            edgesd = edgesd - (ur2d*r2_mag*(r2_mag-dot_ur2)-ur2*(r2_magd&
&             *(r2_mag-dot_ur2)+r2_mag*(r2_magd-dot_ur2d)))/(r2_mag*(&
&             r2_mag-dot_ur2))**2
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edgesd = edgesd + (ur1d*r1_mag*(r1_mag-dot_ur1)-ur1*(r1_magd&
&             *(r1_mag-dot_ur1)+r1_mag*(r1_magd-dot_ur1d)))/(r1_mag*(&
&             r1_mag-dot_ur1))**2
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            ad = bptsd(el_i+0, el_j+0, :)
            a = bpts(el_i+0, el_j+0, :)
            bd = bptsd(el_i+0, el_j+1, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              cd = c_ted
              c = c_te
              dd = d_ted
              d = d_te
            else
              cd = bptsd(el_i+1, el_j+1, :)
              c = bpts(el_i+1, el_j+1, :)
              dd = bptsd(el_i+1, el_j+0, :)
              d = bpts(el_i+1, el_j+0, :)
            end if
            call calc_vorticity_d(b, bd, c, cd, p, pd, edges, edgesd)
            call calc_vorticity_d(d, dd, a, ad, p, pd, edges, edgesd)
            if (symmetry) then
              a_symd = ad
              a_sym = a
              b_symd = bd
              b_sym = b
              c_symd = cd
              c_sym = c
              d_symd = dd
              d_sym = d
              a_symd(2) = -a_symd(2)
              a_sym(2) = -a_sym(2)
              b_symd(2) = -b_symd(2)
              b_sym(2) = -b_sym(2)
              c_symd(2) = -c_symd(2)
              c_sym(2) = -c_sym(2)
              d_symd(2) = -d_symd(2)
              d_sym(2) = -d_sym(2)
              call calc_vorticity_d(c_sym, c_symd, b_sym, b_symd, p, pd&
&                             , edges, edgesd)
              call calc_vorticity_d(a_sym, a_symd, d_sym, d_symd, p, pd&
&                             , edges, edgesd)
            end if
            if (skip .and. cp_loc .eq. el_loc) then
              bound(:) = 0.
              if (symmetry) then
                boundd = (0.0_4,0.0_4)
                call calc_vorticity_d(b_sym, b_symd, a_sym, a_symd, p, &
&                               pd, bound, boundd)
              else
                boundd = (0.0_4,0.0_4)
              end if
              mtxd(cp_loc, el_loc, :) = edgesd + boundd
              mtx(cp_loc, el_loc, :) = edges + bound
            else
              bound(:) = 0.
              boundd = (0.0_4,0.0_4)
              call calc_vorticity_d(a, ad, b, bd, p, pd, bound, boundd)
              if (symmetry) call calc_vorticity_d(b_sym, b_symd, a_sym, &
&                                           a_symd, p, pd, bound, boundd&
&                                          )
              mtxd(cp_loc, el_loc, :) = edgesd + boundd
              mtx(cp_loc, el_loc, :) = edges + bound
            end if
          end do
        end do
      end do
    end do
  end subroutine assembleaeromtx_main_d
  subroutine assembleaeromtx_main(ny, nx, ny_, nx_, alpha, points, bpts&
&   , mesh, skip, symmetry, mtx)
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    complex(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    complex(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, &
&   ny_, 3)
    logical, intent(in) :: skip, symmetry
! output
    complex(kind=8), intent(out) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), &
&   3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    complex(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    complex(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    complex(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    complex(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    complex(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym&
&   (3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
    u(1) = cos(alpha*pi/180.)
    u(2) = 0.
    u(3) = sin(alpha*pi/180.)
    mtx(:, :, :) = 0.
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_te = mesh(nx_, el_j+1, :)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          p = points(cp_i, cp_j, :)
          r1 = p - d_te
          r2 = p - c_te
          call normc(r1, r1_mag)
          call normc(r2, r2_mag)
          call crossc(u, r2, ur2)
          call crossc(u, r1, ur1)
          edges(:) = 0.
          call dotc(u, r2, dot_ur2)
          call dotc(u, r1, dot_ur1)
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          if (symmetry) then
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            call normc(r1, r1_mag)
            call normc(r2, r2_mag)
            call crossc(u, r2, ur2)
            call crossc(u, r1, ur1)
            call dotc(u, r2, dot_ur2)
            call dotc(u, r1, dot_ur1)
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              c = c_te
              d = d_te
            else
              c = bpts(el_i+1, el_j+1, :)
              d = bpts(el_i+1, el_j+0, :)
            end if
            call calc_vorticity(b, c, p, edges)
            call calc_vorticity(d, a, p, edges)
            if (symmetry) then
              a_sym = a
              b_sym = b
              c_sym = c
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              call calc_vorticity(c_sym, b_sym, p, edges)
              call calc_vorticity(a_sym, d_sym, p, edges)
            end if
            if (skip .and. cp_loc .eq. el_loc) then
              bound(:) = 0.
              if (symmetry) call calc_vorticity(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            else
              bound(:) = 0.
              call calc_vorticity(a, b, p, bound)
              if (symmetry) call calc_vorticity(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            end if
          end do
        end do
      end do
    end do
  end subroutine assembleaeromtx_main
!  differentiation of calc_vorticity in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: out
!   with respect to varying inputs: p out a b
  subroutine calc_vorticity_d(a, ad, b, bd, p, pd, out, outd)
    implicit none
! input
    complex(kind=8), intent(in) :: a(3), b(3), p(3)
    complex(kind=8), intent(in) :: ad(3), bd(3), pd(3)
! output
    complex(kind=8), intent(inout) :: out(3)
    complex(kind=8), intent(inout) :: outd(3)
! working
    complex(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    complex(kind=8) :: r1d(3), r2d(3), r1_magd, r2_magd, r1r2d(3), &
&   mag_multd, dot_r1r2d
    r1d = pd - ad
    r1 = p - a
    r2d = pd - bd
    r2 = p - b
    call normc_d(r1, r1d, r1_mag, r1_magd)
    call normc_d(r2, r2d, r2_mag, r2_magd)
    r1r2d = (0.0_4,0.0_4)
    call crossc_d(r1, r1d, r2, r2d, r1r2, r1r2d)
    mag_multd = r1_magd*r2_mag + r1_mag*r2_magd
    mag_mult = r1_mag*r2_mag
    call dotc_d(r1, r1d, r2, r2d, dot_r1r2, dot_r1r2d)
    outd = outd + (((r1_magd+r2_magd)*r1r2+(r1_mag+r2_mag)*r1r2d)*&
&     mag_mult*(mag_mult+dot_r1r2)-(r1_mag+r2_mag)*r1r2*(mag_multd*(&
&     mag_mult+dot_r1r2)+mag_mult*(mag_multd+dot_r1r2d)))/(mag_mult*(&
&     mag_mult+dot_r1r2))**2
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  end subroutine calc_vorticity_d
  subroutine calc_vorticity(a, b, p, out)
    implicit none
! input
    complex(kind=8), intent(in) :: a(3), b(3), p(3)
! output
    complex(kind=8), intent(inout) :: out(3)
! working
    complex(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    r1 = p - a
    r2 = p - b
    call normc(r1, r1_mag)
    call normc(r2, r2_mag)
    call crossc(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    call dotc(r1, r2, dot_r1r2)
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  end subroutine calc_vorticity
  subroutine biotsavart(a, b, p, inf, rev, out)
    implicit none
! input
    complex(kind=8), intent(in) :: a(3), b(3), p(3)
    logical, intent(in) :: inf, rev
! output
    complex(kind=8), intent(inout) :: out(3)
! working
    complex(kind=8) :: rpa, rpb, rab, rh
    complex(kind=8) :: cosa, cosb, c(3)
    complex(kind=8) :: eps, tmp(3), dot_bapa, dot_baba, dot_pbab
    eps = 1e-5
    call normc(a - p, rpa)
    call normc(b - p, rpb)
    call normc(b - a, rab)
    call dotc(b - a, p - a, dot_bapa)
    call dotc(b - a, b - a, dot_baba)
    call dotc(p - b, a - b, dot_pbab)
    call normc(p - a - dot_bapa/dot_baba*(b-a), rh)
    rh = rh + eps
    cosa = dot_bapa/(rpa*rab)
    cosb = dot_pbab/(rpb*rab)
    call crossc(b - p, a - p, c)
    call unitc(c, c)
    if (inf) then
      tmp = -(c/rh*(cosa+1))
    else
      tmp = -(c/rh*(cosa+cosb))
    end if
    if (rev) tmp = -tmp
    out = out + tmp
  end subroutine biotsavart
!  differentiation of unitc in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: u
!   with respect to varying inputs: u v
! complex functions
  subroutine unitc_d(v, vd, u, ud)
    implicit none
    complex(kind=8), intent(in) :: v(3)
    complex(kind=8), intent(in) :: vd(3)
    complex(kind=8), intent(out) :: u(3)
    complex(kind=8), intent(out) :: ud(3)
    complex(kind=8) :: nm
    complex(kind=8) :: nmd
    call normc_d(v, vd, nm, nmd)
    ud(1) = (vd(1)*nm-v(1)*nmd)/nm**2
    u(1) = v(1)/nm
    ud(2) = (vd(2)*nm-v(2)*nmd)/nm**2
    u(2) = v(2)/nm
    ud(3) = (vd(3)*nm-v(3)*nmd)/nm**2
    u(3) = v(3)/nm
  end subroutine unitc_d
! complex functions
  subroutine unitc(v, u)
    implicit none
    complex(kind=8), intent(in) :: v(3)
    complex(kind=8), intent(out) :: u(3)
    complex(kind=8) :: nm
    call normc(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  end subroutine unitc
!  differentiation of normc in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: norm_output
!   with respect to varying inputs: v
  subroutine normc_d(v, vd, norm_output, norm_outputd)
    implicit none
    complex(kind=8), intent(in) :: v(3)
    complex(kind=8), intent(in) :: vd(3)
    complex(kind=8), intent(out) :: norm_output
    complex(kind=8), intent(out) :: norm_outputd
    complex(kind=8) :: dot_prod
    complex(kind=8) :: dot_prodd
!norm = sqrt(dot_product(v, v))
    call dotc_d(v, vd, v, vd, dot_prod, dot_prodd)
    norm_outputd = 0.5*dot_prod**(-0.5)*dot_prodd
    norm_output = dot_prod**0.5
  end subroutine normc_d
  subroutine normc(v, norm_output)
    implicit none
    complex(kind=8), intent(in) :: v(3)
    complex(kind=8), intent(out) :: norm_output
    complex(kind=8) :: dot_prod
!norm = sqrt(dot_product(v, v))
    call dotc(v, v, dot_prod)
    norm_output = dot_prod**0.5
  end subroutine normc
!  differentiation of dotc in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: dot_prod
!   with respect to varying inputs: a b
  subroutine dotc_d(a, ad, b, bd, dot_prod, dot_prodd)
    implicit none
    complex(kind=8), intent(in) :: a(3), b(3)
    complex(kind=8), intent(in) :: ad(3), bd(3)
    complex(kind=8), intent(out) :: dot_prod
    complex(kind=8), intent(out) :: dot_prodd
    dot_prodd = ad(1)*b(1) + a(1)*bd(1) + ad(2)*b(2) + a(2)*bd(2) + ad(3&
&     )*b(3) + a(3)*bd(3)
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dotc_d
  subroutine dotc(a, b, dot_prod)
    implicit none
    complex(kind=8), intent(in) :: a(3), b(3)
    complex(kind=8), intent(out) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dotc
!  differentiation of crossc in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: c
!   with respect to varying inputs: a b c
  subroutine crossc_d(a, ad, b, bd, c, cd)
    implicit none
    complex(kind=8), intent(in) :: a(3), b(3)
    complex(kind=8), intent(in) :: ad(3), bd(3)
    complex(kind=8), intent(out) :: c(3)
    complex(kind=8), intent(out) :: cd(3)
    cd(1) = ad(2)*b(3) + a(2)*bd(3) - ad(3)*b(2) - a(3)*bd(2)
    c(1) = a(2)*b(3) - a(3)*b(2)
    cd(2) = ad(3)*b(1) + a(3)*bd(1) - ad(1)*b(3) - a(1)*bd(3)
    c(2) = a(3)*b(1) - a(1)*b(3)
    cd(3) = ad(1)*b(2) + a(1)*bd(2) - ad(2)*b(1) - a(2)*bd(1)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine crossc_d
  subroutine crossc(a, b, c)
    implicit none
    complex(kind=8), intent(in) :: a(3), b(3)
    complex(kind=8), intent(out) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine crossc
!  differentiation of unit in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: u
!   with respect to varying inputs: u v
! real functions
  subroutine unit_d(v, vd, u, ud)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(in) :: vd(3)
    real(kind=8), intent(out) :: u(3)
    real(kind=8), intent(out) :: ud(3)
    real(kind=8) :: nm
    real(kind=8) :: nmd
    call norm_d(v, vd, nm, nmd)
    ud(1) = (vd(1)*nm-v(1)*nmd)/nm**2
    u(1) = v(1)/nm
    ud(2) = (vd(2)*nm-v(2)*nmd)/nm**2
    u(2) = v(2)/nm
    ud(3) = (vd(3)*nm-v(3)*nmd)/nm**2
    u(3) = v(3)/nm
  end subroutine unit_d
! real functions
  subroutine unit(v, u)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: u(3)
    real(kind=8) :: nm
    call norm(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  end subroutine unit
!  differentiation of norm in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: norm_output
!   with respect to varying inputs: v
  subroutine norm_d(v, vd, norm_output, norm_outputd)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(in) :: vd(3)
    real(kind=8), intent(out) :: norm_output
    real(kind=8), intent(out) :: norm_outputd
    real(kind=8) :: dot_prod
    real(kind=8) :: dot_prodd
!norm = sqrt(dot_product(v, v))
    call dot_d(v, vd, v, vd, dot_prod, dot_prodd)
    if (dot_prod .gt. 0.0_8) then
      norm_outputd = 0.5*dot_prod**(-0.5)*dot_prodd
    else
      norm_outputd = 0.0_8
    end if
    norm_output = dot_prod**0.5
  end subroutine norm_d
  subroutine norm(v, norm_output)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: norm_output
    real(kind=8) :: dot_prod
!norm = sqrt(dot_product(v, v))
    call dot(v, v, dot_prod)
    norm_output = dot_prod**0.5
  end subroutine norm
!  differentiation of dot in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: dot_prod
!   with respect to varying inputs: a b
  subroutine dot_d(a, ad, b, bd, dot_prod, dot_prodd)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(in) :: ad(3), bd(3)
    real(kind=8), intent(out) :: dot_prod
    real(kind=8), intent(out) :: dot_prodd
    dot_prodd = ad(1)*b(1) + a(1)*bd(1) + ad(2)*b(2) + a(2)*bd(2) + ad(3&
&     )*b(3) + a(3)*bd(3)
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot_d
  subroutine dot(a, b, dot_prod)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot
!  differentiation of cross in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: c
!   with respect to varying inputs: a b c
  subroutine cross_d(a, ad, b, bd, c, cd)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(in) :: ad(3), bd(3)
    real(kind=8), intent(out) :: c(3)
    real(kind=8), intent(out) :: cd(3)
    cd(1) = ad(2)*b(3) + a(2)*bd(3) - ad(3)*b(2) - a(3)*bd(2)
    c(1) = a(2)*b(3) - a(3)*b(2)
    cd(2) = ad(3)*b(1) + a(3)*bd(1) - ad(1)*b(3) - a(1)*bd(3)
    c(2) = a(3)*b(1) - a(1)*b(3)
    cd(3) = ad(1)*b(2) + a(1)*bd(2) - ad(2)*b(1) - a(2)*bd(1)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross_d
  subroutine cross(a, b, c)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross
end module oas_main_d
