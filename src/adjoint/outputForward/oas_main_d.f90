!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module oas_main_d
  implicit none

contains
  subroutine mult(nx, ny, x, y)
    implicit none
    integer, intent(in) :: nx, ny
    real*8, intent(in) :: x(nx)
    real*8, intent(out) :: y(ny)
    integer :: i, j
    y(:) = 0.
    do j=1,ny
      do i=1,nx
        y(j) = y(j) + x(i)**2
      end do
    end do
  end subroutine mult
!  differentiation of assemblesparsemtx_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: data
!   with respect to varying inputs: nodes
!   rw status of diff variables: data:out nodes:in
  subroutine assemblesparsemtx_main_d(num_elems, tot_n_fem, nnz, x_gl, e&
&   , g, a, j, iy, iz, nodes, nodesd, elems, coeff_at, coeff_y, coeff_z&
&   , pelem_a, pelem_t, pelem_y, pelem_z, data, datad, rows, cols)
    implicit none
! input
    integer, intent(in) :: tot_n_fem, num_elems, nnz
    real(kind=8), intent(in) :: x_gl(3)
    real(kind=8) :: x_gld(3)
    real(kind=8), intent(in) :: e(num_elems), g(num_elems)
    real(kind=8), intent(in) :: a(num_elems), j(num_elems)
    real(kind=8), intent(in) :: iy(num_elems), iz(num_elems)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3)
    real(kind=8), intent(in) :: nodesd(tot_n_fem, 3)
    integer, intent(in) :: elems(num_elems, 2)
! local stiffness matrix coefficients
    real(kind=8), intent(in) :: coeff_at(2, 2), coeff_y(4, 4), coeff_z(4&
&   , 4)
! local permutation matrices to map to list of dofs for local element
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12)
    real(kind=8) :: pelem_ad(2, 12)
    real(kind=8), intent(in) :: pelem_y(4, 12), pelem_z(4, 12)
    real(kind=8) :: pelem_yd(4, 12)
! output
    real(kind=8), intent(out) :: data(nnz)
    real(kind=8), intent(out) :: datad(nnz)
    integer, intent(out) :: rows(nnz), cols(nnz)
! local stiffness matrices for axial, torsion, bending (y,z)
    real(kind=8) :: kelem_a(2, 2), kelem_t(2, 2)
    real(kind=8) :: kelem_ad(2, 2), kelem_td(2, 2)
    real(kind=8) :: kelem_y(4, 4), kelem_z(4, 4)
    real(kind=8) :: kelem_yd(4, 4), kelem_zd(4, 4)
! local transformation matrix (12,12) to map from local to global frame
    real(kind=8) :: t_elem(12, 12), t(3, 3)
    real(kind=8) :: t_elemd(12, 12), td(3, 3)
! arrays that help in mapping from local element ordering to global ordering
    integer :: rows_elem(12, 12), cols_elem(12, 12)
    integer :: ones11(12, 12), ones12(12, 12)
    integer :: ones21(12, 12), ones22(12, 12)
! local stiffness matrix in global frame
    real(kind=8) :: k_elem(12, 12)
    real(kind=8) :: k_elemd(12, 12)
! miscellaneous
    real(kind=8) :: l, xyz1(3), xyz2(3)
    real(kind=8) :: ld, xyz1d(3), xyz2d(3)
    real(kind=8) :: x_loc(3), y_loc(3), z_loc(3), x_cross(3), y_cross(3)
    real(kind=8) :: x_locd(3), y_locd(3), z_locd(3), x_crossd(3), &
&   y_crossd(3)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2), &
&   res(12, 12)
    real(kind=8) :: mat12x12d(12, 12), mat12x4d(12, 4), mat12x2d(12, 2)&
&   , resd(12, 12)
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2)
    real(kind=8) :: pelem_a_td(12, 2), pelem_t_td(12, 2)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)
    real(kind=8) :: pelem_y_td(12, 4), pelem_z_td(12, 4), t_elem_td(12, &
&   12)
    integer :: i, k1, k2, ind, ind1, ind2, ielem
    intrinsic mod
    real(kind=8) :: pelem_zd(4, 12)
    real(kind=8) :: pelem_td(2, 12)
    do k1=1,12
      do k2=1,12
        rows_elem(k1, k2) = mod(k1 - 1, 6)
        cols_elem(k1, k2) = mod(k2 - 1, 6)
      end do
    end do
    ones11(:, :) = 0
    ones12(:, :) = 0
    ones21(:, :) = 0
    ones22(:, :) = 0
    ones11(1:6, 1:6) = 1
    ones12(1:6, 7:12) = 1
    ones21(7:12, 1:6) = 1
    ones22(7:12, 7:12) = 1
    t_elem(:, :) = 0.
    data(:) = 0.
    rows(:) = 0
    cols(:) = 0
    ind = 0
    datad = 0.0_8
    y_locd = 0.0_8
    td = 0.0_8
    t_elemd = 0.0_8
    z_locd = 0.0_8
    t_elem_td = 0.0_8
    y_crossd = 0.0_8
    x_crossd = 0.0_8
    x_locd = 0.0_8
    do ielem=1,num_elems
      xyz1d = nodesd(elems(ielem, 1), :)
      xyz1 = nodes(elems(ielem, 1), :)
      xyz2d = nodesd(elems(ielem, 2), :)
      xyz2 = nodes(elems(ielem, 2), :)
      call norm_d(xyz2 - xyz1, xyz2d - xyz1d, l, ld)
      call unit_d(xyz2 - xyz1, xyz2d - xyz1d, x_loc, x_locd)
      x_gld = 0.0_8
      call cross_d(x_loc, x_locd, x_gl, x_gld, x_cross, x_crossd)
      call unit_d(x_cross, x_crossd, y_loc, y_locd)
      call cross_d(x_loc, x_locd, y_loc, y_locd, y_cross, y_crossd)
      call unit_d(y_cross, y_crossd, z_loc, z_locd)
      td(1, :) = x_locd
      t(1, :) = x_loc
      td(2, :) = y_locd
      t(2, :) = y_loc
      td(3, :) = z_locd
      t(3, :) = z_loc
      do i=1,4
        t_elemd(3*(i-1)+1:3*(i-1)+3, 3*(i-1)+1:3*(i-1)+3) = td
        t_elem(3*(i-1)+1:3*(i-1)+3, 3*(i-1)+1:3*(i-1)+3) = t
      end do
      kelem_ad = -(coeff_at*e(ielem)*a(ielem)*ld/l**2)
      kelem_a = coeff_at*e(ielem)*a(ielem)/l
      kelem_td = -(coeff_at*g(ielem)*j(ielem)*ld/l**2)
      kelem_t = coeff_at*g(ielem)*j(ielem)/l
      kelem_yd = -(coeff_y*e(ielem)*iy(ielem)*3*l**2*ld/(l**3)**2)
      kelem_y = coeff_y*e(ielem)*iy(ielem)/l**3
      kelem_yd(2:4:2, :) = kelem_yd(2:4:2, :)*l + kelem_y(2:4:2, :)*ld
      kelem_y(2:4:2, :) = kelem_y(2:4:2, :)*l
      kelem_yd(:, 2:4:2) = kelem_yd(:, 2:4:2)*l + kelem_y(:, 2:4:2)*ld
      kelem_y(:, 2:4:2) = kelem_y(:, 2:4:2)*l
      kelem_zd = -(coeff_z*e(ielem)*iz(ielem)*3*l**2*ld/(l**3)**2)
      kelem_z = coeff_z*e(ielem)*iz(ielem)/l**3
      kelem_zd(2:4:2, :) = kelem_zd(2:4:2, :)*l + kelem_z(2:4:2, :)*ld
      kelem_z(2:4:2, :) = kelem_z(2:4:2, :)*l
      kelem_zd(:, 2:4:2) = kelem_zd(:, 2:4:2)*l + kelem_z(:, 2:4:2)*ld
      kelem_z(:, 2:4:2) = kelem_z(:, 2:4:2)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      pelem_a_td = 0.0_8
      call matmul2_d(12, 2, 2, pelem_a_t, pelem_a_td, kelem_a, kelem_ad&
&              , mat12x2, mat12x2d)
      pelem_ad = 0.0_8
      call matmul2_d(12, 2, 12, mat12x2, mat12x2d, pelem_a, pelem_ad, &
&              res, resd)
      k_elemd = resd
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      pelem_t_td = 0.0_8
      call matmul2_d(12, 2, 2, pelem_t_t, pelem_t_td, kelem_t, kelem_td&
&              , mat12x2, mat12x2d)
      pelem_td = 0.0_8
      call matmul2_d(12, 2, 12, mat12x2, mat12x2d, pelem_t, pelem_td, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      pelem_y_td = 0.0_8
      call matmul2_d(12, 4, 4, pelem_y_t, pelem_y_td, kelem_y, kelem_yd&
&              , mat12x4, mat12x4d)
      pelem_yd = 0.0_8
      call matmul2_d(12, 4, 12, mat12x4, mat12x4d, pelem_y, pelem_yd, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      pelem_z_td = 0.0_8
      call matmul2_d(12, 4, 4, pelem_z_t, pelem_z_td, kelem_z, kelem_zd&
&              , mat12x4, mat12x4d)
      pelem_zd = 0.0_8
      call matmul2_d(12, 4, 12, mat12x4, mat12x4d, pelem_z, pelem_zd, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2_d(12, 12, t_elem, t_elemd, t_elem_t, t_elem_td)
      call matmul2_d(12, 12, 12, t_elem_t, t_elem_td, k_elem, k_elemd, &
&              mat12x12, mat12x12d)
      call matmul2_d(12, 12, 12, mat12x12, mat12x12d, t_elem, t_elemd, &
&              k_elem, k_elemd)
      ind1 = 6*(elems(ielem, 1)-1)
      ind2 = 6*(elems(ielem, 2)-1)
      do k1=1,12
        do k2=1,12
          ind = ind + 1
          datad(ind) = datad(ind) + k_elemd(k1, k2)
          data(ind) = data(ind) + k_elem(k1, k2)
          rows(ind) = rows(ind) + rows_elem(k1, k2) + 1
          cols(ind) = cols(ind) + cols_elem(k1, k2) + 1
          rows(ind) = rows(ind) + ones11(k1, k2)*ind1
          cols(ind) = cols(ind) + ones11(k1, k2)*ind1
          rows(ind) = rows(ind) + ones12(k1, k2)*ind1
          cols(ind) = cols(ind) + ones12(k1, k2)*ind2
          rows(ind) = rows(ind) + ones21(k1, k2)*ind2
          cols(ind) = cols(ind) + ones21(k1, k2)*ind1
          rows(ind) = rows(ind) + ones22(k1, k2)*ind2
          cols(ind) = cols(ind) + ones22(k1, k2)*ind2
        end do
      end do
    end do
    if (ind .ne. nnz) print*, &
&         'error in assemblesparsemtx: did not reach end of nnz vectors'
    rows(:) = rows(:) - 1
    cols(:) = cols(:) - 1
  end subroutine assemblesparsemtx_main_d
  subroutine assemblesparsemtx_main(num_elems, tot_n_fem, nnz, x_gl, e, &
&   g, a, j, iy, iz, nodes, elems, coeff_at, coeff_y, coeff_z, pelem_a, &
&   pelem_t, pelem_y, pelem_z, data, rows, cols)
    implicit none
! input
    integer, intent(in) :: tot_n_fem, num_elems, nnz
    real(kind=8), intent(in) :: x_gl(3)
    real(kind=8), intent(in) :: e(num_elems), g(num_elems)
    real(kind=8), intent(in) :: a(num_elems), j(num_elems)
    real(kind=8), intent(in) :: iy(num_elems), iz(num_elems)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3)
    integer, intent(in) :: elems(num_elems, 2)
! local stiffness matrix coefficients
    real(kind=8), intent(in) :: coeff_at(2, 2), coeff_y(4, 4), coeff_z(4&
&   , 4)
! local permutation matrices to map to list of dofs for local element
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12)
    real(kind=8), intent(in) :: pelem_y(4, 12), pelem_z(4, 12)
! output
    real(kind=8), intent(out) :: data(nnz)
    integer, intent(out) :: rows(nnz), cols(nnz)
! local stiffness matrices for axial, torsion, bending (y,z)
    real(kind=8) :: kelem_a(2, 2), kelem_t(2, 2)
    real(kind=8) :: kelem_y(4, 4), kelem_z(4, 4)
! local transformation matrix (12,12) to map from local to global frame
    real(kind=8) :: t_elem(12, 12), t(3, 3)
! arrays that help in mapping from local element ordering to global ordering
    integer :: rows_elem(12, 12), cols_elem(12, 12)
    integer :: ones11(12, 12), ones12(12, 12)
    integer :: ones21(12, 12), ones22(12, 12)
! local stiffness matrix in global frame
    real(kind=8) :: k_elem(12, 12)
! miscellaneous
    real(kind=8) :: l, xyz1(3), xyz2(3)
    real(kind=8) :: x_loc(3), y_loc(3), z_loc(3), x_cross(3), y_cross(3)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2), &
&   res(12, 12)
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)
    integer :: i, k1, k2, ind, ind1, ind2, ielem
    intrinsic mod
    do k1=1,12
      do k2=1,12
        rows_elem(k1, k2) = mod(k1 - 1, 6)
        cols_elem(k1, k2) = mod(k2 - 1, 6)
      end do
    end do
    ones11(:, :) = 0
    ones12(:, :) = 0
    ones21(:, :) = 0
    ones22(:, :) = 0
    ones11(1:6, 1:6) = 1
    ones12(1:6, 7:12) = 1
    ones21(7:12, 1:6) = 1
    ones22(7:12, 7:12) = 1
    t_elem(:, :) = 0.
    data(:) = 0.
    rows(:) = 0
    cols(:) = 0
    ind = 0
    do ielem=1,num_elems
      xyz1 = nodes(elems(ielem, 1), :)
      xyz2 = nodes(elems(ielem, 2), :)
      call norm(xyz2 - xyz1, l)
      call unit(xyz2 - xyz1, x_loc)
      call cross(x_loc, x_gl, x_cross)
      call unit(x_cross, y_loc)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do i=1,4
        t_elem(3*(i-1)+1:3*(i-1)+3, 3*(i-1)+1:3*(i-1)+3) = t
      end do
      kelem_a = coeff_at*e(ielem)*a(ielem)/l
      kelem_t = coeff_at*g(ielem)*j(ielem)/l
      kelem_y = coeff_y*e(ielem)*iy(ielem)/l**3
      kelem_y(2:4:2, :) = kelem_y(2:4:2, :)*l
      kelem_y(:, 2:4:2) = kelem_y(:, 2:4:2)*l
      kelem_z = coeff_z*e(ielem)*iz(ielem)/l**3
      kelem_z(2:4:2, :) = kelem_z(2:4:2, :)*l
      kelem_z(:, 2:4:2) = kelem_z(:, 2:4:2)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call matmul2(12, 2, 2, pelem_a_t, kelem_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call matmul2(12, 2, 2, pelem_t_t, kelem_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call matmul2(12, 4, 4, pelem_y_t, kelem_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call matmul2(12, 4, 4, pelem_z_t, kelem_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call transpose2(12, 12, t_elem, t_elem_t)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      call matmul2(12, 12, 12, mat12x12, t_elem, k_elem)
      ind1 = 6*(elems(ielem, 1)-1)
      ind2 = 6*(elems(ielem, 2)-1)
      do k1=1,12
        do k2=1,12
          ind = ind + 1
          data(ind) = data(ind) + k_elem(k1, k2)
          rows(ind) = rows(ind) + rows_elem(k1, k2) + 1
          cols(ind) = cols(ind) + cols_elem(k1, k2) + 1
          rows(ind) = rows(ind) + ones11(k1, k2)*ind1
          cols(ind) = cols(ind) + ones11(k1, k2)*ind1
          rows(ind) = rows(ind) + ones12(k1, k2)*ind1
          cols(ind) = cols(ind) + ones12(k1, k2)*ind2
          rows(ind) = rows(ind) + ones21(k1, k2)*ind2
          cols(ind) = cols(ind) + ones21(k1, k2)*ind1
          rows(ind) = rows(ind) + ones22(k1, k2)*ind2
          cols(ind) = cols(ind) + ones22(k1, k2)*ind2
        end do
      end do
    end do
    if (ind .ne. nnz) print*, &
&         'error in assemblesparsemtx: did not reach end of nnz vectors'
    rows(:) = rows(:) - 1
    cols(:) = cols(:) - 1
  end subroutine assemblesparsemtx_main
!  differentiation of assemblestructmtx_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: x
!   with respect to varying inputs: j nodes iy iz rhs a
!   rw status of diff variables: j:in k:(loc) x:out nodes:in iy:in
!                iz:in rhs:in a:in
! 6
! 4
! 3
! 3
! 6
  subroutine assemblestructmtx_main_d(n, tot_n_fem, size, nodes, nodesd&
&   , a, ad, j, jd, iy, iyd, iz, izd, k_a, k_t, k_y, k_z, elem_ids, cons&
&   , e, g, x_gl, t, k_elem, pelem_a, pelem_t, pelem_y, pelem_z, t_elem&
&   , const2, const_y, const_z, rhs, rhsd, k, kd, x, xd)
! 7
    use solveroutines, only : solve_d
    implicit none
! input
    integer, intent(in) :: n, size, cons, tot_n_fem
    integer, intent(inout) :: elem_ids(n-1, 2)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8), intent(in) :: nodesd(tot_n_fem, 3), ad(n-1), jd(n-1), &
&   iyd(n-1), izd(n-1)
    real(kind=8), intent(in) :: e(n-1), g(n-1), x_gl(3)
    real(kind=8) :: x_gld(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8) :: k_ad(2, 2)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8) :: td(3, 3)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8) :: pelem_ad(2, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4), rhs(size)
    real(kind=8), intent(in) :: rhsd(size)
! output
    real(kind=8), intent(out) :: x(size), k(size, size)
    real(kind=8), intent(out) :: xd(size), kd(size, size)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: p0d(3), p1d(3), x_locd(3), y_locd(3), z_locd(3), &
&   x_crossd(3), y_crossd(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: ld, ea_ld, gj_ld, eiy_l3d, eiz_l3d, resd(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    real(kind=8) :: mat12x12d(12, 12), mat12x4d(12, 4), mat12x2d(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(size, size)
    real(kind=8) :: pelem_a_td(12, 2), pelem_t_td(12, 2), k_d(size, size&
&   )
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)&
&   , b(size)
    real(kind=8) :: pelem_y_td(12, 4), pelem_z_td(12, 4), t_elem_td(12, &
&   12), bd(size)
    integer :: ipiv(size), n_solve
    real(kind=8) :: pelem_zd(4, 12)
    real(kind=8) :: k_elemd(12, 12)
    real(kind=8) :: k_yd(4, 4)
    real(kind=8) :: pelem_yd(4, 12)
    real(kind=8) :: t_elemd(12, 12)
    real(kind=8) :: k_td(2, 2)
    real(kind=8) :: k_zd(4, 4)
    real(kind=8) :: pelem_td(2, 12)
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    k(:, :) = 0.
    kd = 0.0_8
    td = 0.0_8
    t_elemd = 0.0_8
    y_locd = 0.0_8
    z_locd = 0.0_8
    t_elem_td = 0.0_8
    y_crossd = 0.0_8
    x_crossd = 0.0_8
    x_locd = 0.0_8
! loop over num elements
    do ielem=1,num_elems
      p0d = nodesd(elem_ids(ielem, 1), :)
      p0 = nodes(elem_ids(ielem, 1), :)
      p1d = nodesd(elem_ids(ielem, 2), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      call unit_d(p1 - p0, p1d - p0d, x_loc, x_locd)
      x_gld = 0.0_8
      call cross_d(x_loc, x_locd, x_gl, x_gld, x_cross, x_crossd)
      call unit_d(x_cross, x_crossd, y_loc, y_locd)
      call cross_d(x_loc, x_locd, y_loc, y_locd, y_cross, y_crossd)
      call unit_d(y_cross, y_crossd, z_loc, z_locd)
      td(1, :) = x_locd
      t(1, :) = x_loc
      td(2, :) = y_locd
      t(2, :) = y_loc
      td(3, :) = z_locd
      t(3, :) = z_loc
      do ind=1,4
        t_elemd(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = td
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      call norm_d(p1 - p0, p1d - p0d, l, ld)
      ea_ld = (e(ielem)*ad(ielem)*l-e(ielem)*a(ielem)*ld)/l**2
      ea_l = e(ielem)*a(ielem)/l
      gj_ld = (g(ielem)*jd(ielem)*l-g(ielem)*j(ielem)*ld)/l**2
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3d = (e(ielem)*iyd(ielem)*l**3-e(ielem)*iy(ielem)*3*l**2*ld)/&
&       (l**3)**2
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3d = (e(ielem)*izd(ielem)*l**3-e(ielem)*iz(ielem)*3*l**2*ld)/&
&       (l**3)**2
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_ad(:, :) = const2*ea_ld
      k_a(:, :) = ea_l*const2
      k_td(:, :) = const2*gj_ld
      k_t(:, :) = gj_l*const2
      k_yd(:, :) = const_y*eiy_l3d
      k_y(:, :) = eiy_l3*const_y
      k_yd(2, :) = k_yd(2, :)*l + k_y(2, :)*ld
      k_y(2, :) = k_y(2, :)*l
      k_yd(4, :) = k_yd(4, :)*l + k_y(4, :)*ld
      k_y(4, :) = k_y(4, :)*l
      k_yd(:, 2) = k_yd(:, 2)*l + k_y(:, 2)*ld
      k_y(:, 2) = k_y(:, 2)*l
      k_yd(:, 4) = k_yd(:, 4)*l + k_y(:, 4)*ld
      k_y(:, 4) = k_y(:, 4)*l
      k_zd(:, :) = const_z*eiz_l3d
      k_z(:, :) = eiz_l3*const_z
      k_zd(2, :) = k_zd(2, :)*l + k_z(2, :)*ld
      k_z(2, :) = k_z(2, :)*l
      k_zd(4, :) = k_zd(4, :)*l + k_z(4, :)*ld
      k_z(4, :) = k_z(4, :)*l
      k_zd(:, 2) = k_zd(:, 2)*l + k_z(:, 2)*ld
      k_z(:, 2) = k_z(:, 2)*l
      k_zd(:, 4) = k_zd(:, 4)*l + k_z(:, 4)*ld
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      pelem_a_td = 0.0_8
      call matmul2_d(12, 2, 2, pelem_a_t, pelem_a_td, k_a, k_ad, mat12x2&
&              , mat12x2d)
      pelem_ad = 0.0_8
      call matmul2_d(12, 2, 12, mat12x2, mat12x2d, pelem_a, pelem_ad, &
&              res, resd)
      k_elemd = resd
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      pelem_t_td = 0.0_8
      call matmul2_d(12, 2, 2, pelem_t_t, pelem_t_td, k_t, k_td, mat12x2&
&              , mat12x2d)
      pelem_td = 0.0_8
      call matmul2_d(12, 2, 12, mat12x2, mat12x2d, pelem_t, pelem_td, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      pelem_y_td = 0.0_8
      call matmul2_d(12, 4, 4, pelem_y_t, pelem_y_td, k_y, k_yd, mat12x4&
&              , mat12x4d)
      pelem_yd = 0.0_8
      call matmul2_d(12, 4, 12, mat12x4, mat12x4d, pelem_y, pelem_yd, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      pelem_z_td = 0.0_8
      call matmul2_d(12, 4, 4, pelem_z_t, pelem_z_td, k_z, k_zd, mat12x4&
&              , mat12x4d)
      pelem_zd = 0.0_8
      call matmul2_d(12, 4, 12, mat12x4, mat12x4d, pelem_z, pelem_zd, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2_d(12, 12, t_elem, t_elemd, t_elem_t, t_elem_td)
      call matmul2_d(12, 12, 12, t_elem_t, t_elem_td, k_elem, k_elemd, &
&              mat12x12, mat12x12d)
      call matmul2_d(12, 12, 12, mat12x12, mat12x12d, t_elem, t_elemd, &
&              res, resd)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      kd(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = kd(6*(in0-1&
&       )+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + resd(:6, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      kd(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = kd(6*(in1-1&
&       )+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + resd(7:, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      kd(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = kd(6*(in0-1&
&       )+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + resd(:6, 7:)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      kd(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = kd(6*(in1-1&
&       )+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + resd(7:, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      kd(6*num_nodes+i, 6*cons+i) = 0.0_8
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      kd(6*cons+i, 6*num_nodes+i) = 0.0_8
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
    n_solve = size
    bd = rhsd
    b = rhs
    k_d = kd
    k_ = k
    xd = 0.0_8
    call solve_d(k_, k_d, x, xd, b, bd, n_solve, ipiv)
  end subroutine assemblestructmtx_main_d
! 6
! 4
! 3
! 3
! 6
  subroutine assemblestructmtx_main(n, tot_n_fem, size, nodes, a, j, iy&
&   , iz, k_a, k_t, k_y, k_z, elem_ids, cons, e, g, x_gl, t, k_elem, &
&   pelem_a, pelem_t, pelem_y, pelem_z, t_elem, const2, const_y, const_z&
&   , rhs, k, x)
! 7
    use solveroutines, only : solve
    implicit none
! input
    integer, intent(in) :: n, size, cons, tot_n_fem
    integer, intent(inout) :: elem_ids(n-1, 2)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8), intent(in) :: e(n-1), g(n-1), x_gl(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4), rhs(size)
! output
    real(kind=8), intent(out) :: x(size), k(size, size)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(size, size)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)&
&   , b(size)
    integer :: ipiv(size), n_solve
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    k(:, :) = 0.
! loop over num elements
    do ielem=1,num_elems
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      call unit(p1 - p0, x_loc)
      call cross(x_loc, x_gl, x_cross)
      call unit(x_cross, y_loc)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do ind=1,4
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      call norm(p1 - p0, l)
      ea_l = e(ielem)*a(ielem)/l
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      k_y(:, :) = eiy_l3*const_y
      k_y(2, :) = k_y(2, :)*l
      k_y(4, :) = k_y(4, :)*l
      k_y(:, 2) = k_y(:, 2)*l
      k_y(:, 4) = k_y(:, 4)*l
      k_z(:, :) = eiz_l3*const_z
      k_z(2, :) = k_z(2, :)*l
      k_z(4, :) = k_z(4, :)*l
      k_z(:, 2) = k_z(:, 2)*l
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call matmul2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call matmul2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call matmul2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call matmul2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call transpose2(12, 12, t_elem, t_elem_t)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      call matmul2(12, 12, 12, mat12x12, t_elem, res)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
    n_solve = size
    b = rhs
    k_ = k
    call solve(k_, x, b, n_solve, ipiv)
  end subroutine assemblestructmtx_main
!  differentiation of transpose2 in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: new_mtx
!   with respect to varying inputs: new_mtx mtx
  subroutine transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8), intent(in) :: mtxd(m, n)
    real(kind=8), intent(out) :: new_mtx(n, m)
    real(kind=8), intent(out) :: new_mtxd(n, m)
    integer :: i, j
    do i=1,m
      do j=1,n
        new_mtxd(j, i) = mtxd(i, j)
        new_mtx(j, i) = mtx(i, j)
      end do
    end do
  end subroutine transpose2_d
  subroutine transpose2(m, n, mtx, new_mtx)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8), intent(out) :: new_mtx(n, m)
    integer :: i, j
    do i=1,m
      do j=1,n
        new_mtx(j, i) = mtx(i, j)
      end do
    end do
  end subroutine transpose2
!  differentiation of matmul2 in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: c
!   with respect to varying inputs: a b
  subroutine matmul2_d(m, n, p, a, ad, b, bd, c, cd)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8), intent(in) :: ad(m, n), bd(n, p)
    real(kind=8), intent(out) :: c(m, p)
    real(kind=8), intent(out) :: cd(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    cd = 0.0_8
    do i=1,m
      do j=1,p
        do k=1,n
          cd(i, j) = cd(i, j) + ad(i, k)*b(k, j) + a(i, k)*bd(k, j)
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2_d
  subroutine matmul2(m, n, p, a, b, c)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8), intent(out) :: c(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    do i=1,m
      do j=1,p
        do k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2
!  differentiation of unit in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: u
!   with respect to varying inputs: u v
  subroutine unit_d(v, vd, u, ud)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(in) :: vd(3)
    real(kind=8), intent(out) :: u(3)
    real(kind=8), intent(out) :: ud(3)
    real(kind=8) :: nm
    real(kind=8) :: nmd
    call norm_d(v, vd, nm, nmd)
    ud(1) = (vd(1)*nm-v(1)*nmd)/nm**2
    u(1) = v(1)/nm
    ud(2) = (vd(2)*nm-v(2)*nmd)/nm**2
    u(2) = v(2)/nm
    ud(3) = (vd(3)*nm-v(3)*nmd)/nm**2
    u(3) = v(3)/nm
  end subroutine unit_d
!  differentiation of assembleaeromtx_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: mtx
!   with respect to varying inputs: alpha points mesh bpts
!   rw status of diff variables: alpha:in points:in mesh:in bpts:in
!                mtx:out
  subroutine assembleaeromtx_main_d(ny, nx, ny_, nx_, alpha, alphad, &
&   points, pointsd, bpts, bptsd, mesh, meshd, skip, symmetry, mtx, mtxd&
& )
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    real(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    real(kind=8), intent(in) :: alphad, meshd(nx_, ny_, 3)
    real(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, ny_, &
&   3)
    real(kind=8), intent(in) :: pointsd(nx-1, ny-1, 3), bptsd(nx_-1, ny_&
&   , 3)
    logical, intent(in) :: skip, symmetry
! output
    real(kind=8), intent(out) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
    real(kind=8), intent(out) :: mtxd((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    real(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    real(kind=8) :: pd(3), ad(3), bd(3), ud(3), cd(3), dd(3)
    real(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    real(kind=8) :: a_symd(3), b_symd(3), c_symd(3), d_symd(3)
    real(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    real(kind=8) :: ur2d(3), r1d(3), r2d(3), r1_magd, r2_magd
    real(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    real(kind=8) :: ur1d(3), boundd(3), dot_ur2d, dot_ur1d
    real(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym(3)
    real(kind=8) :: edgesd(3), c_ted(3), d_ted(3), c_te_symd(3), &
&   d_te_symd(3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
    ud = 0.0_8
    ud(1) = -(pi*alphad*sin(alpha*pi/180.)/180.)
    u(1) = cos(alpha*pi/180.)
    ud(2) = 0.0_8
    u(2) = 0.
    ud(3) = pi*alphad*cos(alpha*pi/180.)/180.
    u(3) = sin(alpha*pi/180.)
    mtx(:, :, :) = 0.
    mtxd = 0.0_8
    ur1d = 0.0_8
    ur2d = 0.0_8
    a_symd = 0.0_8
    c_te_symd = 0.0_8
    b_symd = 0.0_8
    d_te_symd = 0.0_8
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_ted = meshd(nx_, el_j+1, :)
      c_te = mesh(nx_, el_j+1, :)
      d_ted = meshd(nx_, el_j+0, :)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_symd = c_ted
        c_te_sym = c_te
        d_te_symd = d_ted
        d_te_sym = d_te
        c_te_symd(2) = -c_te_symd(2)
        c_te_sym(2) = -c_te_sym(2)
        d_te_symd(2) = -d_te_symd(2)
        d_te_sym(2) = -d_te_sym(2)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          pd = pointsd(cp_i, cp_j, :)
          p = points(cp_i, cp_j, :)
          r1d = pd - d_ted
          r1 = p - d_te
          r2d = pd - c_ted
          r2 = p - c_te
          call norm_d(r1, r1d, r1_mag, r1_magd)
          call norm_d(r2, r2d, r2_mag, r2_magd)
          call cross_d(u, ud, r2, r2d, ur2, ur2d)
          call cross_d(u, ud, r1, r1d, ur1, ur1d)
          edges(:) = 0.
          call dot_d(u, ud, r2, r2d, dot_ur2, dot_ur2d)
          call dot_d(u, ud, r1, r1d, dot_ur1, dot_ur1d)
          edgesd = (ur2d*r2_mag*(r2_mag-dot_ur2)-ur2*(r2_magd*(r2_mag-&
&           dot_ur2)+r2_mag*(r2_magd-dot_ur2d)))/(r2_mag*(r2_mag-dot_ur2&
&           ))**2
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edgesd = edgesd - (ur1d*r1_mag*(r1_mag-dot_ur1)-ur1*(r1_magd*(&
&           r1_mag-dot_ur1)+r1_mag*(r1_magd-dot_ur1d)))/(r1_mag*(r1_mag-&
&           dot_ur1))**2
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          if (symmetry) then
            r1d = pd - d_te_symd
            r1 = p - d_te_sym
            r2d = pd - c_te_symd
            r2 = p - c_te_sym
            call norm_d(r1, r1d, r1_mag, r1_magd)
            call norm_d(r2, r2d, r2_mag, r2_magd)
            call cross_d(u, ud, r2, r2d, ur2, ur2d)
            call cross_d(u, ud, r1, r1d, ur1, ur1d)
            call dot_d(u, ud, r2, r2d, dot_ur2, dot_ur2d)
            call dot_d(u, ud, r1, r1d, dot_ur1, dot_ur1d)
            edgesd = edgesd - (ur2d*r2_mag*(r2_mag-dot_ur2)-ur2*(r2_magd&
&             *(r2_mag-dot_ur2)+r2_mag*(r2_magd-dot_ur2d)))/(r2_mag*(&
&             r2_mag-dot_ur2))**2
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edgesd = edgesd + (ur1d*r1_mag*(r1_mag-dot_ur1)-ur1*(r1_magd&
&             *(r1_mag-dot_ur1)+r1_mag*(r1_magd-dot_ur1d)))/(r1_mag*(&
&             r1_mag-dot_ur1))**2
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            ad = bptsd(el_i+0, el_j+0, :)
            a = bpts(el_i+0, el_j+0, :)
            bd = bptsd(el_i+0, el_j+1, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              cd = c_ted
              c = c_te
              dd = d_ted
              d = d_te
            else
              cd = bptsd(el_i+1, el_j+1, :)
              c = bpts(el_i+1, el_j+1, :)
              dd = bptsd(el_i+1, el_j+0, :)
              d = bpts(el_i+1, el_j+0, :)
            end if
            call calc_vorticity_d(b, bd, c, cd, p, pd, edges, edgesd)
            call calc_vorticity_d(d, dd, a, ad, p, pd, edges, edgesd)
            if (symmetry) then
              a_symd = ad
              a_sym = a
              b_symd = bd
              b_sym = b
              c_symd = cd
              c_sym = c
              d_symd = dd
              d_sym = d
              a_symd(2) = -a_symd(2)
              a_sym(2) = -a_sym(2)
              b_symd(2) = -b_symd(2)
              b_sym(2) = -b_sym(2)
              c_symd(2) = -c_symd(2)
              c_sym(2) = -c_sym(2)
              d_symd(2) = -d_symd(2)
              d_sym(2) = -d_sym(2)
              call calc_vorticity_d(c_sym, c_symd, b_sym, b_symd, p, pd&
&                             , edges, edgesd)
              call calc_vorticity_d(a_sym, a_symd, d_sym, d_symd, p, pd&
&                             , edges, edgesd)
            end if
            if (skip .and. cp_loc .eq. el_loc) then
              bound(:) = 0.
              if (symmetry) then
                boundd = 0.0_8
                call calc_vorticity_d(b_sym, b_symd, a_sym, a_symd, p, &
&                               pd, bound, boundd)
              else
                boundd = 0.0_8
              end if
              mtxd(cp_loc, el_loc, :) = edgesd + boundd
              mtx(cp_loc, el_loc, :) = edges + bound
            else
              bound(:) = 0.
              boundd = 0.0_8
              call calc_vorticity_d(a, ad, b, bd, p, pd, bound, boundd)
              if (symmetry) call calc_vorticity_d(b_sym, b_symd, a_sym, &
&                                           a_symd, p, pd, bound, boundd&
&                                          )
              mtxd(cp_loc, el_loc, :) = edgesd + boundd
              mtx(cp_loc, el_loc, :) = edges + bound
            end if
          end do
        end do
      end do
    end do
  end subroutine assembleaeromtx_main_d
  subroutine assembleaeromtx_main(ny, nx, ny_, nx_, alpha, points, bpts&
&   , mesh, skip, symmetry, mtx)
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    real(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    real(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, ny_, &
&   3)
    logical, intent(in) :: skip, symmetry
! output
    real(kind=8), intent(out) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    real(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    real(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    real(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    real(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    real(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym(3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
    u(1) = cos(alpha*pi/180.)
    u(2) = 0.
    u(3) = sin(alpha*pi/180.)
    mtx(:, :, :) = 0.
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_te = mesh(nx_, el_j+1, :)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          p = points(cp_i, cp_j, :)
          r1 = p - d_te
          r2 = p - c_te
          call norm(r1, r1_mag)
          call norm(r2, r2_mag)
          call cross(u, r2, ur2)
          call cross(u, r1, ur1)
          edges(:) = 0.
          call dot(u, r2, dot_ur2)
          call dot(u, r1, dot_ur1)
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          if (symmetry) then
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            call norm(r1, r1_mag)
            call norm(r2, r2_mag)
            call cross(u, r2, ur2)
            call cross(u, r1, ur1)
            call dot(u, r2, dot_ur2)
            call dot(u, r1, dot_ur1)
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              c = c_te
              d = d_te
            else
              c = bpts(el_i+1, el_j+1, :)
              d = bpts(el_i+1, el_j+0, :)
            end if
            call calc_vorticity(b, c, p, edges)
            call calc_vorticity(d, a, p, edges)
            if (symmetry) then
              a_sym = a
              b_sym = b
              c_sym = c
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              call calc_vorticity(c_sym, b_sym, p, edges)
              call calc_vorticity(a_sym, d_sym, p, edges)
            end if
            if (skip .and. cp_loc .eq. el_loc) then
              bound(:) = 0.
              if (symmetry) call calc_vorticity(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            else
              bound(:) = 0.
              call calc_vorticity(a, b, p, bound)
              if (symmetry) call calc_vorticity(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            end if
          end do
        end do
      end do
    end do
  end subroutine assembleaeromtx_main
!  differentiation of calc_vorticity in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: out
!   with respect to varying inputs: p out a b
  subroutine calc_vorticity_d(a, ad, b, bd, p, pd, out, outd)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
    real(kind=8), intent(in) :: ad(3), bd(3), pd(3)
! output
    real(kind=8), intent(inout) :: out(3)
    real(kind=8), intent(inout) :: outd(3)
! working
    real(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    real(kind=8) :: r1d(3), r2d(3), r1_magd, r2_magd, r1r2d(3), &
&   mag_multd, dot_r1r2d
    r1d = pd - ad
    r1 = p - a
    r2d = pd - bd
    r2 = p - b
    call norm_d(r1, r1d, r1_mag, r1_magd)
    call norm_d(r2, r2d, r2_mag, r2_magd)
    r1r2d = 0.0_8
    call cross_d(r1, r1d, r2, r2d, r1r2, r1r2d)
    mag_multd = r1_magd*r2_mag + r1_mag*r2_magd
    mag_mult = r1_mag*r2_mag
    call dot_d(r1, r1d, r2, r2d, dot_r1r2, dot_r1r2d)
    outd = outd + (((r1_magd+r2_magd)*r1r2+(r1_mag+r2_mag)*r1r2d)*&
&     mag_mult*(mag_mult+dot_r1r2)-(r1_mag+r2_mag)*r1r2*(mag_multd*(&
&     mag_mult+dot_r1r2)+mag_mult*(mag_multd+dot_r1r2d)))/(mag_mult*(&
&     mag_mult+dot_r1r2))**2
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  end subroutine calc_vorticity_d
  subroutine calc_vorticity(a, b, p, out)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
! output
    real(kind=8), intent(inout) :: out(3)
! working
    real(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    r1 = p - a
    r2 = p - b
    call norm(r1, r1_mag)
    call norm(r2, r2_mag)
    call cross(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    call dot(r1, r2, dot_r1r2)
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  end subroutine calc_vorticity
  subroutine biotsavart(a, b, p, inf, rev, out)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
    logical, intent(in) :: inf, rev
! output
    real(kind=8), intent(inout) :: out(3)
! working
    real(kind=8) :: rpa, rpb, rab, rh
    real(kind=8) :: cosa, cosb, c(3)
    real(kind=8) :: eps, tmp(3), dot_bapa, dot_baba, dot_pbab
    eps = 1e-5
    call norm(a - p, rpa)
    call norm(b - p, rpb)
    call norm(b - a, rab)
    call dot(b - a, p - a, dot_bapa)
    call dot(b - a, b - a, dot_baba)
    call dot(p - b, a - b, dot_pbab)
    call norm(p - a - dot_bapa/dot_baba*(b-a), rh)
    rh = rh + eps
    cosa = dot_bapa/(rpa*rab)
    cosb = dot_pbab/(rpb*rab)
    call cross(b - p, a - p, c)
    call unit(c, c)
    if (inf) then
      tmp = -(c/rh*(cosa+1))
    else
      tmp = -(c/rh*(cosa+cosb))
    end if
    if (rev) tmp = -tmp
    out = out + tmp
  end subroutine biotsavart
  subroutine unit(v, u)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: u(3)
    real(kind=8) :: nm
    call norm(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  end subroutine unit
!  differentiation of norm in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: norm_output
!   with respect to varying inputs: v
  subroutine norm_d(v, vd, norm_output, norm_outputd)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(in) :: vd(3)
    real(kind=8), intent(out) :: norm_output
    real(kind=8), intent(out) :: norm_outputd
    real(kind=8) :: dot_prod
    real(kind=8) :: dot_prodd
!norm = sqrt(dot_product(v, v))
    call dot_d(v, vd, v, vd, dot_prod, dot_prodd)
    if (dot_prod .gt. 0.0_8) then
      norm_outputd = 0.5*dot_prod**(-0.5)*dot_prodd
    else
      norm_outputd = 0.0_8
    end if
    norm_output = dot_prod**0.5
  end subroutine norm_d
  subroutine norm(v, norm_output)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: norm_output
    real(kind=8) :: dot_prod
!norm = sqrt(dot_product(v, v))
    call dot(v, v, dot_prod)
    norm_output = dot_prod**0.5
  end subroutine norm
!  differentiation of dot in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: dot_prod
!   with respect to varying inputs: a b
  subroutine dot_d(a, ad, b, bd, dot_prod, dot_prodd)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(in) :: ad(3), bd(3)
    real(kind=8), intent(out) :: dot_prod
    real(kind=8), intent(out) :: dot_prodd
    dot_prodd = ad(1)*b(1) + a(1)*bd(1) + ad(2)*b(2) + a(2)*bd(2) + ad(3&
&     )*b(3) + a(3)*bd(3)
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot_d
  subroutine dot(a, b, dot_prod)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot
!  differentiation of cross in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: c
!   with respect to varying inputs: a b c
  subroutine cross_d(a, ad, b, bd, c, cd)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(in) :: ad(3), bd(3)
    real(kind=8), intent(out) :: c(3)
    real(kind=8), intent(out) :: cd(3)
    cd(1) = ad(2)*b(3) + a(2)*bd(3) - ad(3)*b(2) - a(3)*bd(2)
    c(1) = a(2)*b(3) - a(3)*b(2)
    cd(2) = ad(3)*b(1) + a(3)*bd(1) - ad(1)*b(3) - a(1)*bd(3)
    c(2) = a(3)*b(1) - a(1)*b(3)
    cd(3) = ad(1)*b(2) + a(1)*bd(2) - ad(2)*b(1) - a(2)*bd(1)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross_d
  subroutine cross(a, b, c)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross
end module oas_main_d
