!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module oas_main_b
  implicit none

contains
!  differentiation of mult_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: x y
!   with respect to varying inputs: x y
!   rw status of diff variables: x:incr y:in-zero
  subroutine mult_main_b(nx, ny, x, xb, y, yb)
    implicit none
    integer, intent(in) :: nx, ny
    real*8, intent(in) :: x(nx)
    real*8 :: xb(nx)
    real*8 :: y(ny)
    real*8 :: yb(ny)
    integer :: i, j
    do j=ny,1,-1
      do i=nx,1,-1
        xb(i) = xb(i) + 2*x(i)*yb(j)
      end do
    end do
    yb = 0.0_8
  end subroutine mult_main_b
  subroutine mult_main(nx, ny, x, y)
    implicit none
    integer, intent(in) :: nx, ny
    real*8, intent(in) :: x(nx)
    real*8, intent(out) :: y(ny)
    integer :: i, j
    y(:) = 0.
    do j=1,ny
      do i=1,nx
        y(j) = y(j) + x(i)**2 + j
      end do
    end do
  end subroutine mult_main
!  differentiation of calc_vonmises_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: r vonmises nodes disp
!   with respect to varying inputs: r vonmises nodes disp
!   rw status of diff variables: r:incr vonmises:in-zero nodes:incr
!                disp:incr
  subroutine calc_vonmises_main_b(elem_ids, nodes, nodesb, r, rb, disp, &
&   dispb, e, g, x_gl, num_elems, n, vonmises, vonmisesb)
    implicit none
! input
    integer, intent(in) :: elem_ids(num_elems, 2), num_elems, n
    real(kind=8), intent(in) :: nodes(n, 3), r(num_elems), disp(n, 6)
    real(kind=8) :: nodesb(n, 3), rb(num_elems), dispb(n, 6)
    real(kind=8), intent(in) :: e, g, x_gl(3)
    real(kind=8) :: x_glb(3)
! output
    real(kind=8) :: vonmises(num_elems, 2)
    real(kind=8) :: vonmisesb(num_elems, 2)
! working
    integer :: ielem, in0, in1
    real(kind=8) :: p0(3), p1(3), l, x_loc(3), y_loc(3), z_loc(3), t(3, &
&   3)
    real(kind=8) :: p0b(3), p1b(3), lb, x_locb(3), y_locb(3), z_locb(3)&
&   , tb(3, 3)
    real(kind=8) :: u0(3), r0(3), u1(3), r1(3), sxx0, sxx1, sxt, tmp
    real(kind=8) :: u0b(3), r0b(3), u1b(3), r1b(3), sxx0b, sxx1b, sxtb, &
&   tmpb
    real(kind=8) :: y_raw(3), z_raw(3), r1r0(3), t1(3), t2(3), t3(3), t4&
&   (3)
    real(kind=8) :: y_rawb(3), z_rawb(3), r1r0b(3), t1b(3), t2b(3), t3b(&
&   3), t4b(3)
    real(kind=8) :: nodes2(n, 3), r2(num_elems), disp2(n, 6), p1p0(3)
    real(kind=8) :: nodes2b(n, 3), r2b(num_elems), disp2b(n, 6), p1p0b(3&
&   )
    real(kind=8) :: tempb6
    real(kind=8) :: tempb5
    real(kind=8) :: tempb4
    real(kind=8) :: tempb3
    real(kind=8) :: tempb2
    real(kind=8) :: tempb1
    real(kind=8) :: tempb0
    real(kind=8) :: tempb
    real(kind=8) :: temp
    nodes2 = nodes
    r2 = r
    disp2 = disp
    do ielem=1,num_elems
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      p0 = nodes2(in0, :)
      p1 = nodes2(in1, :)
      p1p0 = p1 - p0
      call pushreal8(l)
      call norm(p1p0, l)
      call pushreal8array(x_loc, 3)
      call unit(p1p0, x_loc)
      call pushreal8array(y_raw, 3)
      call cross(x_loc, x_gl, y_raw)
      call pushreal8array(y_loc, 3)
      call unit(y_raw, y_loc)
      call pushreal8array(z_raw, 3)
      call cross(x_loc, y_loc, z_raw)
      call unit(z_raw, z_loc)
      call pushreal8array(t(1, :), 3)
      t(1, :) = x_loc
      call pushreal8array(t(2, :), 3)
      t(2, :) = y_loc
      call pushreal8array(t(3, :), 3)
      t(3, :) = z_loc
      t1 = disp2(in0, 1:3)
      t2 = disp2(in0, 4:6)
      t3 = disp2(in1, 1:3)
      t4 = disp2(in1, 4:6)
      call pushreal8array(u0, 3)
      call matmul2(3, 3, 1, t, t1, u0)
      call matmul2(3, 3, 1, t, t2, r0)
      call pushreal8array(u1, 3)
      call matmul2(3, 3, 1, t, t3, u1)
      call matmul2(3, 3, 1, t, t4, r1)
      call pushreal8array(r1r0, 3)
      r1r0 = r1 - r0
    end do
    y_locb = 0.0_8
    tb = 0.0_8
    nodes2b = 0.0_8
    z_locb = 0.0_8
    y_rawb = 0.0_8
    r2b = 0.0_8
    z_rawb = 0.0_8
    disp2b = 0.0_8
    x_locb = 0.0_8
    do ielem=num_elems,1,-1
      sxt = g*r2(ielem)*r1r0(1)/l
      tmp = (r1r0(2)**2+r1r0(3)**2)**.5
      sxx1 = e*(u0(1)-u1(1))/l + e*r2(ielem)/l*tmp
      tempb = .5*(sxx1**2+sxt**2)**(-0.5)*vonmisesb(ielem, 2)
      sxx1b = 2*sxx1*tempb
      vonmisesb(ielem, 2) = 0.0_8
      sxx0 = e*(u1(1)-u0(1))/l + e*r2(ielem)/l*tmp
      tempb0 = .5*(sxx0**2+sxt**2)**(-0.5)*vonmisesb(ielem, 1)
      sxtb = 2*sxt*tempb0 + 2*sxt*tempb
      sxx0b = 2*sxx0*tempb0
      vonmisesb(ielem, 1) = 0.0_8
      r1r0b = 0.0_8
      temp = r1r0(1)/l
      tempb1 = r2(ielem)*g*sxtb/l
      r2b(ielem) = r2b(ielem) + e*tmp*sxx1b/l + e*tmp*sxx0b/l + g*temp*&
&       sxtb
      r1r0b(1) = r1r0b(1) + tempb1
      u0b = 0.0_8
      u1b = 0.0_8
      tempb2 = e*sxx1b/l
      tempb3 = r2(ielem)*e*sxx1b/l
      tempb5 = e*sxx0b/l
      u0b(1) = u0b(1) + tempb2 - tempb5
      u1b(1) = u1b(1) + tempb5 - tempb2
      tempb4 = r2(ielem)*e*sxx0b/l
      lb = -((u0(1)-u1(1))*tempb2/l) - tmp*tempb3/l - tmp*tempb4/l - (u1&
&       (1)-u0(1))*tempb5/l - temp*tempb1
      tmpb = tempb4 + tempb3
      tempb6 = .5*(r1r0(2)**2+r1r0(3)**2)**(-0.5)*tmpb
      r1r0b(2) = r1r0b(2) + 2*r1r0(2)*tempb6
      r1r0b(3) = r1r0b(3) + 2*r1r0(3)*tempb6
      r0b = 0.0_8
      r1b = 0.0_8
      call popreal8array(r1r0, 3)
      r1b = r1r0b
      r0b = -r1r0b
      in1 = elem_ids(ielem, 2)
      t4 = disp2(in1, 4:6)
      t4b = 0.0_8
      call matmul2_b(3, 3, 1, t, tb, t4, t4b, r1, r1b)
      t3 = disp2(in1, 1:3)
      call popreal8array(u1, 3)
      t3b = 0.0_8
      call matmul2_b(3, 3, 1, t, tb, t3, t3b, u1, u1b)
      in0 = elem_ids(ielem, 1)
      t2 = disp2(in0, 4:6)
      t2b = 0.0_8
      call matmul2_b(3, 3, 1, t, tb, t2, t2b, r0, r0b)
      t1 = disp2(in0, 1:3)
      call popreal8array(u0, 3)
      t1b = 0.0_8
      call matmul2_b(3, 3, 1, t, tb, t1, t1b, u0, u0b)
      disp2b(in1, 4:6) = disp2b(in1, 4:6) + t4b
      disp2b(in1, 1:3) = disp2b(in1, 1:3) + t3b
      disp2b(in0, 4:6) = disp2b(in0, 4:6) + t2b
      disp2b(in0, 1:3) = disp2b(in0, 1:3) + t1b
      call popreal8array(t(3, :), 3)
      z_locb = z_locb + tb(3, :)
      tb(3, :) = 0.0_8
      call popreal8array(t(2, :), 3)
      y_locb = y_locb + tb(2, :)
      tb(2, :) = 0.0_8
      call popreal8array(t(1, :), 3)
      x_locb = x_locb + tb(1, :)
      tb(1, :) = 0.0_8
      call unit_b(z_raw, z_rawb, z_loc, z_locb)
      call popreal8array(z_raw, 3)
      call cross_b(x_loc, x_locb, y_loc, y_locb, z_raw, z_rawb)
      call popreal8array(y_loc, 3)
      call unit_b(y_raw, y_rawb, y_loc, y_locb)
      call popreal8array(y_raw, 3)
      x_glb = 0.0_8
      call cross_b(x_loc, x_locb, x_gl, x_glb, y_raw, y_rawb)
      p0 = nodes2(in0, :)
      p1 = nodes2(in1, :)
      p1p0 = p1 - p0
      call popreal8array(x_loc, 3)
      p1p0b = 0.0_8
      call unit_b(p1p0, p1p0b, x_loc, x_locb)
      call popreal8(l)
      call norm_b(p1p0, p1p0b, l, lb)
      p0b = 0.0_8
      p1b = 0.0_8
      p1b = p1p0b
      p0b = -p1p0b
      nodes2b(in1, :) = nodes2b(in1, :) + p1b
      nodes2b(in0, :) = nodes2b(in0, :) + p0b
    end do
    dispb = dispb + disp2b
    rb = rb + r2b
    nodesb = nodesb + nodes2b
    vonmisesb = 0.0_8
  end subroutine calc_vonmises_main_b
  subroutine calc_vonmises_main(elem_ids, nodes, r, disp, e, g, x_gl, &
&   num_elems, n, vonmises)
    implicit none
! input
    integer, intent(in) :: elem_ids(num_elems, 2), num_elems, n
    real(kind=8), intent(in) :: nodes(n, 3), r(num_elems), disp(n, 6)
    real(kind=8), intent(in) :: e, g, x_gl(3)
! output
    real(kind=8), intent(out) :: vonmises(num_elems, 2)
! working
    integer :: ielem, in0, in1
    real(kind=8) :: p0(3), p1(3), l, x_loc(3), y_loc(3), z_loc(3), t(3, &
&   3)
    real(kind=8) :: u0(3), r0(3), u1(3), r1(3), sxx0, sxx1, sxt, tmp
    real(kind=8) :: y_raw(3), z_raw(3), r1r0(3), t1(3), t2(3), t3(3), t4&
&   (3)
    real(kind=8) :: nodes2(n, 3), r2(num_elems), disp2(n, 6), p1p0(3)
    vonmises(:, :) = 0.
    nodes2 = nodes
    r2 = r
    disp2 = disp
    do ielem=1,num_elems
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      p0 = nodes2(in0, :)
      p1 = nodes2(in1, :)
      p1p0 = p1 - p0
      call norm(p1p0, l)
      call unit(p1p0, x_loc)
      call cross(x_loc, x_gl, y_raw)
      call unit(y_raw, y_loc)
      call cross(x_loc, y_loc, z_raw)
      call unit(z_raw, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      t1 = disp2(in0, 1:3)
      t2 = disp2(in0, 4:6)
      t3 = disp2(in1, 1:3)
      t4 = disp2(in1, 4:6)
      call matmul2(3, 3, 1, t, t1, u0)
      call matmul2(3, 3, 1, t, t2, r0)
      call matmul2(3, 3, 1, t, t3, u1)
      call matmul2(3, 3, 1, t, t4, r1)
      r1r0 = r1 - r0
      tmp = (r1r0(2)**2+r1r0(3)**2)**.5
      sxx0 = e*(u1(1)-u0(1))/l + e*r2(ielem)/l*tmp
      sxx1 = e*(u0(1)-u1(1))/l + e*r2(ielem)/l*tmp
      sxt = g*r2(ielem)*r1r0(1)/l
      vonmises(ielem, 1) = (sxx0**2+sxt**2)**.5
      vonmises(ielem, 2) = (sxx1**2+sxt**2)**.5
    end do
  end subroutine calc_vonmises_main
!  differentiation of transferdisplacements_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: mesh def_mesh disp
!   with respect to varying inputs: mesh def_mesh disp
!   rw status of diff variables: mesh:incr def_mesh:in-zero disp:incr
  subroutine transferdisplacements_main_b(nx, ny, mesh, meshb, disp, &
&   dispb, w, def_mesh, def_meshb)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3), disp(ny, 6), w
    real(kind=8) :: meshb(nx, ny, 3), dispb(ny, 6)
! output
    real(kind=8) :: def_mesh(nx, ny, 3)
    real(kind=8) :: def_meshb(nx, ny, 3)
! working
    integer :: ind, indx
    real(kind=8) :: smesh(nx, ny, 3), t(3, 3), t_base(3, 3), vec(3)
    real(kind=8) :: smeshb(nx, ny, 3), tb(3, 3), vecb(3)
    real(kind=8) :: sinr(3), cosr(3), r(3), ref_curve(ny, 3)
    real(kind=8) :: sinrb(3), cosrb(3), rb(3), ref_curveb(ny, 3)
    intrinsic cos
    intrinsic sin
    ref_curve = (1-w)*mesh(1, :, :) + w*mesh(nx, :, :)
    t_base(:, :) = 0.
    do ind=1,3
      t_base(ind, ind) = -2.
    end do
    do ind=1,nx
      smesh(ind, :, :) = mesh(ind, :, :) - ref_curve
    end do
    do ind=1,ny
      r = disp(ind, 4:6)
      cosr = cos(r)
      sinr = sin(r)
      call pushreal8array(t, 3**2)
      t(:, :) = 0.
      t(1, 1) = cosr(3) + cosr(2)
      t(2, 2) = cosr(3) + cosr(1)
      t(3, 3) = cosr(1) + cosr(2)
      t(1, 2) = -sinr(3)
      t(1, 3) = sinr(2)
      t(2, 1) = sinr(3)
      t(2, 3) = -sinr(1)
      t(3, 1) = -sinr(2)
      t(3, 2) = sinr(1)
      t = t + t_base
    end do
    meshb = meshb + def_meshb
    smeshb = 0.0_8
    do ind=ny,1,-1
      dispb(ind, 3) = dispb(ind, 3) + sum(def_meshb(:, ind, 3))
      dispb(ind, 2) = dispb(ind, 2) + sum(def_meshb(:, ind, 2))
      dispb(ind, 1) = dispb(ind, 1) + sum(def_meshb(:, ind, 1))
      tb = 0.0_8
      do indx=nx,1,-1
        vecb = 0.0_8
        vecb = def_meshb(indx, ind, :)
        call matmul2_b(1, 3, 3, smesh(indx, ind, :), smeshb(indx, ind, :&
&                ), t, tb, vec, vecb)
      end do
      sinrb = 0.0_8
      sinrb(1) = sinrb(1) + tb(3, 2)
      tb(3, 2) = 0.0_8
      sinrb(2) = sinrb(2) - tb(3, 1)
      tb(3, 1) = 0.0_8
      sinrb(1) = sinrb(1) - tb(2, 3)
      tb(2, 3) = 0.0_8
      sinrb(3) = sinrb(3) + tb(2, 1)
      tb(2, 1) = 0.0_8
      sinrb(2) = sinrb(2) + tb(1, 3)
      tb(1, 3) = 0.0_8
      sinrb(3) = sinrb(3) - tb(1, 2)
      tb(1, 2) = 0.0_8
      cosrb = 0.0_8
      cosrb(1) = cosrb(1) + tb(3, 3)
      cosrb(2) = cosrb(2) + tb(3, 3)
      tb(3, 3) = 0.0_8
      cosrb(3) = cosrb(3) + tb(2, 2)
      cosrb(1) = cosrb(1) + tb(2, 2)
      tb(2, 2) = 0.0_8
      cosrb(3) = cosrb(3) + tb(1, 1)
      cosrb(2) = cosrb(2) + tb(1, 1)
      call popreal8array(t, 3**2)
      r = disp(ind, 4:6)
      rb = 0.0_8
      rb = cos(r)*sinrb - sin(r)*cosrb
      dispb(ind, 4:6) = dispb(ind, 4:6) + rb
    end do
    ref_curveb = 0.0_8
    do ind=nx,1,-1
      meshb(ind, :, :) = meshb(ind, :, :) + smeshb(ind, :, :)
      ref_curveb = ref_curveb - smeshb(ind, :, :)
      smeshb(ind, :, :) = 0.0_8
    end do
    meshb(1, :, :) = meshb(1, :, :) + (1-w)*ref_curveb
    meshb(nx, :, :) = meshb(nx, :, :) + w*ref_curveb
    def_meshb = 0.0_8
  end subroutine transferdisplacements_main_b
  subroutine transferdisplacements_main(nx, ny, mesh, disp, w, def_mesh)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3), disp(ny, 6), w
! output
    real(kind=8), intent(out) :: def_mesh(nx, ny, 3)
! working
    integer :: ind, indx
    real(kind=8) :: smesh(nx, ny, 3), t(3, 3), t_base(3, 3), vec(3)
    real(kind=8) :: sinr(3), cosr(3), r(3), ref_curve(ny, 3)
    intrinsic cos
    intrinsic sin
    ref_curve = (1-w)*mesh(1, :, :) + w*mesh(nx, :, :)
    def_mesh(:, :, :) = 0.
    t_base(:, :) = 0.
    do ind=1,3
      t_base(ind, ind) = -2.
    end do
    do ind=1,nx
      smesh(ind, :, :) = mesh(ind, :, :) - ref_curve
    end do
    do ind=1,ny
      r = disp(ind, 4:6)
      cosr = cos(r)
      sinr = sin(r)
      t(:, :) = 0.
      t(1, 1) = cosr(3) + cosr(2)
      t(2, 2) = cosr(3) + cosr(1)
      t(3, 3) = cosr(1) + cosr(2)
      t(1, 2) = -sinr(3)
      t(1, 3) = sinr(2)
      t(2, 1) = sinr(3)
      t(2, 3) = -sinr(1)
      t(3, 1) = -sinr(2)
      t(3, 2) = sinr(1)
      t = t + t_base
      do indx=1,nx
        call matmul2(1, 3, 3, smesh(indx, ind, :), t, vec)
        def_mesh(indx, ind, :) = def_mesh(indx, ind, :) + vec
      end do
      def_mesh(:, ind, 1) = def_mesh(:, ind, 1) + disp(ind, 1)
      def_mesh(:, ind, 2) = def_mesh(:, ind, 2) + disp(ind, 2)
      def_mesh(:, ind, 3) = def_mesh(:, ind, 3) + disp(ind, 3)
    end do
    def_mesh = def_mesh + mesh
  end subroutine transferdisplacements_main
!  differentiation of assemblestructmtx_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: k x
!   with respect to varying inputs: loads j k x nodes iy iz a
!   rw status of diff variables: loads:out j:out k:in-zero x:in-out
!                nodes:out iy:out iz:out a:out
! 6
! 4
! 3
! 3
! 6
  subroutine assemblestructmtx_main_b(n, tot_n_fem, nodes, nodesb, a, ab&
&   , j, jb, iy, iyb, iz, izb, k_a, k_t, k_y, k_z, elem_ids, cons, e, g&
&   , x_gl, t, k_elem, pelem_a, pelem_t, pelem_y, pelem_z, t_elem, &
&   const2, const_y, const_z, loads, loadsb, k, kb, x, xb)
! 7
    use solveroutines, only : solve_b
    implicit none
! input
    integer, intent(in) :: n, cons, tot_n_fem
    integer, intent(inout) :: elem_ids(n-1, 2)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8) :: nodesb(tot_n_fem, 3), ab(n-1), jb(n-1), iyb(n-1), &
&   izb(n-1)
    real(kind=8), intent(in) :: e(n-1), g(n-1), x_gl(3)
    real(kind=8) :: x_glb(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8) :: pelem_ab(2, 12), pelem_tb(2, 12), pelem_yb(4, 12), &
&   pelem_zb(4, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4), loads(n, 6)
    real(kind=8) :: loadsb(n, 6)
! output
    real(kind=8) :: x(6*n+6), k(6*n+6, 6*n+6)
    real(kind=8) :: xb(6*n+6), kb(6*n+6, 6*n+6)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: p0b(3), p1b(3), x_locb(3), y_locb(3), z_locb(3), &
&   x_crossb(3), y_crossb(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: lb, ea_lb, gj_lb, eiy_l3b, eiz_l3b, resb(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    real(kind=8) :: mat12x12b(12, 12), mat12x4b(12, 4), mat12x2b(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(6*n+6, 6*n+6)&
&   , rhs(6*n+6)
    real(kind=8) :: pelem_a_tb(12, 2), pelem_t_tb(12, 2), k_b(6*n+6, 6*n&
&   +6), rhsb(6*n+6)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)&
&   , b(6*n+6)
    real(kind=8) :: pelem_y_tb(12, 4), pelem_z_tb(12, 4), t_elem_tb(12, &
&   12), bb(6*n+6)
    integer :: ipiv(6*n+6), n_solve
    real(kind=8), dimension(3) :: arg1
    real(kind=8), dimension(3) :: arg1b
    real(kind=8) :: temp0
    real(kind=8) :: tb(3, 3)
    real(kind=8) :: k_elemb(12, 12)
    real(kind=8) :: k_yb(4, 4)
    real(kind=8) :: tempb2
    real(kind=8) :: tempb1
    real(kind=8) :: tempb0
    real(kind=8) :: tempb
    real(kind=8) :: k_ab(2, 2)
    real(kind=8) :: t_elemb(12, 12)
    real(kind=8) :: k_tb(2, 2)
    real(kind=8) :: k_zb(4, 4)
    real(kind=8) :: temp
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    rhs(:) = 0.
    do ind=1,n
      do i=1,6
        rhs((ind-1)*6+i) = loads(ind, i)
      end do
    end do
    k(:, :) = 0.
! loop over num elements
    do ielem=1,num_elems
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      arg1(:) = p1 - p0
      call pushreal8array(x_loc, 3)
      call unit(arg1(:), x_loc)
      call pushreal8array(x_cross, 3)
      call cross(x_loc, x_gl, x_cross)
      call pushreal8array(y_loc, 3)
      call unit(x_cross, y_loc)
      call pushreal8array(y_cross, 3)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do ind=1,4
        call pushreal8array(t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:&
&                     3*(ind-1)+3), 3**2)
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      arg1(:) = p1 - p0
      call pushreal8(l)
      call norm(arg1(:), l)
      ea_l = e(ielem)*a(ielem)/l
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      call pushreal8array(k_y, 4**2)
      k_y(:, :) = eiy_l3*const_y
      call pushreal8array(k_y(2, :), 4)
      k_y(2, :) = k_y(2, :)*l
      call pushreal8array(k_y(4, :), 4)
      k_y(4, :) = k_y(4, :)*l
      call pushreal8array(k_y(:, 2), 4)
      k_y(:, 2) = k_y(:, 2)*l
      call pushreal8array(k_y(:, 4), 4)
      k_y(:, 4) = k_y(:, 4)*l
      call pushreal8array(k_z, 4**2)
      k_z(:, :) = eiz_l3*const_z
      call pushreal8array(k_z(2, :), 4)
      k_z(2, :) = k_z(2, :)*l
      call pushreal8array(k_z(4, :), 4)
      k_z(4, :) = k_z(4, :)*l
      call pushreal8array(k_z(:, 2), 4)
      k_z(:, 2) = k_z(:, 2)*l
      call pushreal8array(k_z(:, 4), 4)
      k_z(:, 4) = k_z(:, 4)*l
      call pushreal8array(k_elem, 12**2)
      k_elem(:, :) = 0.
      call pushreal8array(pelem_a_t, 12*2)
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call pushreal8array(mat12x2, 12*2)
      call matmul2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_t_t, 12*2)
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call pushreal8array(mat12x2, 12*2)
      call matmul2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_y_t, 12*4)
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call pushreal8array(mat12x4, 12*4)
      call matmul2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_z_t, 12*4)
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call pushreal8array(mat12x4, 12*4)
      call matmul2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call pushreal8array(t_elem_t, 12**2)
      call transpose2(12, 12, t_elem, t_elem_t)
      call pushreal8array(mat12x12, 12**2)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      call matmul2(12, 12, 12, mat12x12, t_elem, res)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
    n_solve = 6*n + 6
    b = rhs
    k_ = k
    k_b = 0.0_8
    bb = 0.0_8
    call solve_b(k_, k_b, x, xb, b, bb, n_solve, ipiv)
    kb = kb + k_b
    rhsb = 0.0_8
    rhsb = bb
    do i=6,1,-1
      kb(6*cons+i, 6*num_nodes+i) = 0.0_8
      kb(6*num_nodes+i, 6*cons+i) = 0.0_8
    end do
    jb = 0.0_8
    tb = 0.0_8
    t_elemb = 0.0_8
    nodesb = 0.0_8
    iyb = 0.0_8
    izb = 0.0_8
    ab = 0.0_8
    y_locb = 0.0_8
    z_locb = 0.0_8
    t_elem_tb = 0.0_8
    y_crossb = 0.0_8
    x_crossb = 0.0_8
    x_locb = 0.0_8
    do ielem=num_elems,1,-1
      in1 = elem_ids(ielem, 2)
      resb = 0.0_8
      resb(7:12, 7:12) = resb(7:12, 7:12) + kb(6*(in1-1)+1:6*(in1-1)+6, &
&       6*(in1-1)+1:6*(in1-1)+6)
      in0 = elem_ids(ielem, 1)
      resb(1:6, 7:12) = resb(1:6, 7:12) + kb(6*(in0-1)+1:6*(in0-1)+6, 6*&
&       (in1-1)+1:6*(in1-1)+6)
      resb(7:12, 1:6) = resb(7:12, 1:6) + kb(6*(in1-1)+1:6*(in1-1)+6, 6*&
&       (in0-1)+1:6*(in0-1)+6)
      resb(1:6, 1:6) = resb(1:6, 1:6) + kb(6*(in0-1)+1:6*(in0-1)+6, 6*(&
&       in0-1)+1:6*(in0-1)+6)
      mat12x12b = 0.0_8
      call matmul2_b(12, 12, 12, mat12x12, mat12x12b, t_elem, t_elemb, &
&              res, resb)
      call popreal8array(mat12x12, 12**2)
      k_elemb = 0.0_8
      call matmul2_b(12, 12, 12, t_elem_t, t_elem_tb, k_elem, k_elemb, &
&              mat12x12, mat12x12b)
      call popreal8array(t_elem_t, 12**2)
      call transpose2_b(12, 12, t_elem, t_elemb, t_elem_t, t_elem_tb)
      resb = 0.0_8
      resb = k_elemb
      mat12x4b = 0.0_8
      pelem_zb = 0.0_8
      call matmul2_b(12, 4, 12, mat12x4, mat12x4b, pelem_z, pelem_zb, &
&              res, resb)
      call popreal8array(mat12x4, 12*4)
      pelem_z_tb = 0.0_8
      k_zb = 0.0_8
      call matmul2_b(12, 4, 4, pelem_z_t, pelem_z_tb, k_z, k_zb, mat12x4&
&              , mat12x4b)
      call popreal8array(pelem_z_t, 12*4)
      resb = 0.0_8
      resb = k_elemb
      mat12x4b = 0.0_8
      pelem_yb = 0.0_8
      call matmul2_b(12, 4, 12, mat12x4, mat12x4b, pelem_y, pelem_yb, &
&              res, resb)
      call popreal8array(mat12x4, 12*4)
      pelem_y_tb = 0.0_8
      k_yb = 0.0_8
      call matmul2_b(12, 4, 4, pelem_y_t, pelem_y_tb, k_y, k_yb, mat12x4&
&              , mat12x4b)
      call popreal8array(pelem_y_t, 12*4)
      resb = 0.0_8
      resb = k_elemb
      mat12x2b = 0.0_8
      pelem_tb = 0.0_8
      call matmul2_b(12, 2, 12, mat12x2, mat12x2b, pelem_t, pelem_tb, &
&              res, resb)
      gj_l = g(ielem)*j(ielem)/l
      k_t(:, :) = gj_l*const2
      call popreal8array(mat12x2, 12*2)
      pelem_t_tb = 0.0_8
      k_tb = 0.0_8
      call matmul2_b(12, 2, 2, pelem_t_t, pelem_t_tb, k_t, k_tb, mat12x2&
&              , mat12x2b)
      call popreal8array(pelem_t_t, 12*2)
      resb = 0.0_8
      resb = k_elemb
      mat12x2b = 0.0_8
      pelem_ab = 0.0_8
      call matmul2_b(12, 2, 12, mat12x2, mat12x2b, pelem_a, pelem_ab, &
&              res, resb)
      ea_l = e(ielem)*a(ielem)/l
      k_a(:, :) = ea_l*const2
      call popreal8array(mat12x2, 12*2)
      pelem_a_tb = 0.0_8
      k_ab = 0.0_8
      call matmul2_b(12, 2, 2, pelem_a_t, pelem_a_tb, k_a, k_ab, mat12x2&
&              , mat12x2b)
      call popreal8array(pelem_a_t, 12*2)
      call popreal8array(k_elem, 12**2)
      call popreal8array(k_z(:, 4), 4)
      lb = sum(k_z(:, 4)*k_zb(:, 4))
      k_zb(:, 4) = l*k_zb(:, 4)
      call popreal8array(k_z(:, 2), 4)
      lb = lb + sum(k_z(:, 2)*k_zb(:, 2))
      k_zb(:, 2) = l*k_zb(:, 2)
      call popreal8array(k_z(4, :), 4)
      lb = lb + sum(k_z(4, :)*k_zb(4, :))
      k_zb(4, :) = l*k_zb(4, :)
      call popreal8array(k_z(2, :), 4)
      lb = lb + sum(k_z(2, :)*k_zb(2, :))
      k_zb(2, :) = l*k_zb(2, :)
      call popreal8array(k_z, 4**2)
      eiz_l3b = sum(const_z*k_zb(:, :))
      call popreal8array(k_y(:, 4), 4)
      lb = lb + sum(k_y(:, 4)*k_yb(:, 4))
      k_yb(:, 4) = l*k_yb(:, 4)
      call popreal8array(k_y(:, 2), 4)
      lb = lb + sum(k_y(:, 2)*k_yb(:, 2))
      k_yb(:, 2) = l*k_yb(:, 2)
      call popreal8array(k_y(4, :), 4)
      lb = lb + sum(k_y(4, :)*k_yb(4, :))
      k_yb(4, :) = l*k_yb(4, :)
      call popreal8array(k_y(2, :), 4)
      lb = lb + sum(k_y(2, :)*k_yb(2, :))
      k_yb(2, :) = l*k_yb(2, :)
      call popreal8array(k_y, 4**2)
      eiy_l3b = sum(const_y*k_yb(:, :))
      gj_lb = sum(const2*k_tb(:, :))
      ea_lb = sum(const2*k_ab(:, :))
      temp0 = l**3
      tempb = e(ielem)*eiz_l3b/temp0
      izb(ielem) = izb(ielem) + tempb
      temp = l**3
      tempb0 = e(ielem)*eiy_l3b/temp
      iyb(ielem) = iyb(ielem) + tempb0
      tempb2 = g(ielem)*gj_lb/l
      jb(ielem) = jb(ielem) + tempb2
      tempb1 = e(ielem)*ea_lb/l
      lb = lb - iy(ielem)*3*l**2*tempb0/temp - a(ielem)*tempb1/l - j(&
&       ielem)*tempb2/l - iz(ielem)*3*l**2*tempb/temp0
      ab(ielem) = ab(ielem) + tempb1
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      arg1(:) = p1 - p0
      call popreal8(l)
      arg1b = 0.0_8
      call norm_b(arg1(:), arg1b(:), l, lb)
      p0b = 0.0_8
      p1b = 0.0_8
      p1b = arg1b(:)
      p0b = -arg1b(:)
      do ind=4,1,-1
        call popreal8array(t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3&
&                    *(ind-1)+3), 3**2)
        tb = tb + t_elemb(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)&
&         +3)
        t_elemb(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = &
&         0.0_8
      end do
      z_locb = z_locb + tb(3, :)
      tb(3, :) = 0.0_8
      y_locb = y_locb + tb(2, :)
      tb(2, :) = 0.0_8
      x_locb = x_locb + tb(1, :)
      tb(1, :) = 0.0_8
      call unit_b(y_cross, y_crossb, z_loc, z_locb)
      call popreal8array(y_cross, 3)
      call cross_b(x_loc, x_locb, y_loc, y_locb, y_cross, y_crossb)
      call popreal8array(y_loc, 3)
      call unit_b(x_cross, x_crossb, y_loc, y_locb)
      call popreal8array(x_cross, 3)
      x_glb = 0.0_8
      call cross_b(x_loc, x_locb, x_gl, x_glb, x_cross, x_crossb)
      arg1(:) = p1 - p0
      call popreal8array(x_loc, 3)
      arg1b = 0.0_8
      call unit_b(arg1(:), arg1b(:), x_loc, x_locb)
      p1b = p1b + arg1b
      p0b = p0b - arg1b
      nodesb(elem_ids(ielem, 2), :) = nodesb(elem_ids(ielem, 2), :) + &
&       p1b
      nodesb(elem_ids(ielem, 1), :) = nodesb(elem_ids(ielem, 1), :) + &
&       p0b
    end do
    loadsb = 0.0_8
    do ind=n,1,-1
      do i=6,1,-1
        loadsb(ind, i) = loadsb(ind, i) + rhsb((ind-1)*6+i)
        rhsb((ind-1)*6+i) = 0.0_8
      end do
    end do
    kb = 0.0_8
  end subroutine assemblestructmtx_main_b
! 6
! 4
! 3
! 3
! 6
  subroutine assemblestructmtx_main(n, tot_n_fem, nodes, a, j, iy, iz, &
&   k_a, k_t, k_y, k_z, elem_ids, cons, e, g, x_gl, t, k_elem, pelem_a, &
&   pelem_t, pelem_y, pelem_z, t_elem, const2, const_y, const_z, loads, &
&   k, x)
! 7
    use solveroutines, only : solve
    implicit none
! input
    integer, intent(in) :: n, cons, tot_n_fem
    integer, intent(inout) :: elem_ids(n-1, 2)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8), intent(in) :: e(n-1), g(n-1), x_gl(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4), loads(n, 6)
! output
    real(kind=8), intent(out) :: x(6*n+6), k(6*n+6, 6*n+6)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(6*n+6, 6*n+6)&
&   , rhs(6*n+6)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)&
&   , b(6*n+6)
    integer :: ipiv(6*n+6), n_solve
    real(kind=8), dimension(3) :: arg1
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    rhs(:) = 0.
    do ind=1,n
      do i=1,6
        rhs((ind-1)*6+i) = loads(ind, i)
      end do
    end do
    k(:, :) = 0.
! loop over num elements
    do ielem=1,num_elems
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      arg1(:) = p1 - p0
      call unit(arg1(:), x_loc)
      call cross(x_loc, x_gl, x_cross)
      call unit(x_cross, y_loc)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do ind=1,4
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      arg1(:) = p1 - p0
      call norm(arg1(:), l)
      ea_l = e(ielem)*a(ielem)/l
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      k_y(:, :) = eiy_l3*const_y
      k_y(2, :) = k_y(2, :)*l
      k_y(4, :) = k_y(4, :)*l
      k_y(:, 2) = k_y(:, 2)*l
      k_y(:, 4) = k_y(:, 4)*l
      k_z(:, :) = eiz_l3*const_z
      k_z(2, :) = k_z(2, :)*l
      k_z(4, :) = k_z(4, :)*l
      k_z(:, 2) = k_z(:, 2)*l
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call matmul2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call matmul2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call matmul2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call matmul2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call transpose2(12, 12, t_elem, t_elem_t)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      call matmul2(12, 12, 12, mat12x12, t_elem, res)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
    n_solve = 6*n + 6
    b = rhs
    k_ = k
    call solve(k_, x, b, n_solve, ipiv)
  end subroutine assemblestructmtx_main
!  differentiation of transpose2 in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: new_mtx mtx
!   with respect to varying inputs: new_mtx mtx
  subroutine transpose2_b(m, n, mtx, mtxb, new_mtx, new_mtxb)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8) :: mtxb(m, n)
    real(kind=8) :: new_mtx(n, m)
    real(kind=8) :: new_mtxb(n, m)
    integer :: i, j
    do i=m,1,-1
      do j=n,1,-1
        mtxb(i, j) = mtxb(i, j) + new_mtxb(j, i)
        new_mtxb(j, i) = 0.0_8
      end do
    end do
  end subroutine transpose2_b
  subroutine transpose2(m, n, mtx, new_mtx)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8), intent(out) :: new_mtx(n, m)
    integer :: i, j
    do i=1,m
      do j=1,n
        new_mtx(j, i) = mtx(i, j)
      end do
    end do
  end subroutine transpose2
!  differentiation of matmul2 in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b
  subroutine matmul2_b(m, n, p, a, ab, b, bb, c, cb)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8) :: ab(m, n), bb(n, p)
    real(kind=8) :: c(m, p)
    real(kind=8) :: cb(m, p)
    integer :: i, j, k
    do i=m,1,-1
      do j=p,1,-1
        do k=n,1,-1
          ab(i, k) = ab(i, k) + b(k, j)*cb(i, j)
          bb(k, j) = bb(k, j) + a(i, k)*cb(i, j)
        end do
      end do
    end do
  end subroutine matmul2_b
  subroutine matmul2(m, n, p, a, b, c)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8), intent(out) :: c(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    do i=1,m
      do j=1,p
        do k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2
  subroutine matmul2c(m, n, p, a, b, c)
    implicit none
    integer, intent(in) :: m, n, p
    complex(kind=8), intent(in) :: a(m, n), b(n, p)
    complex(kind=8), intent(out) :: c(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    do i=1,m
      do j=1,p
        do k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2c
!  differentiation of assembleaeromtx_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: mtx
!   with respect to varying inputs: alpha points mesh bpts mtx
!   rw status of diff variables: alpha:out points:out mesh:out
!                bpts:out mtx:in-zero
  subroutine assembleaeromtx_main_b(ny, nx, ny_, nx_, alpha, alphab, &
&   points, pointsb, bpts, bptsb, mesh, meshb, skip, symmetry, mtx, mtxb&
& )
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    complex(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    complex(kind=8) :: alphab, meshb(nx_, ny_, 3)
    complex(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, &
&   ny_, 3)
    complex(kind=8) :: pointsb(nx-1, ny-1, 3), bptsb(nx_-1, ny_, 3)
    logical, intent(in) :: skip, symmetry
! output
    complex(kind=8) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
    complex(kind=8) :: mtxb((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    complex(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    complex(kind=8) :: pb(3), ab(3), bb(3), ub(3), cb(3), db(3)
    complex(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    complex(kind=8) :: a_symb(3), b_symb(3), c_symb(3), d_symb(3)
    complex(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    complex(kind=8) :: ur2b(3), r1b(3), r2b(3), r1_magb, r2_magb
    complex(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    complex(kind=8) :: ur1b(3), boundb(3), dot_ur2b, dot_ur1b
    complex(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym&
&   (3)
    complex(kind=8) :: edgesb(3), c_teb(3), d_teb(3), c_te_symb(3), &
&   d_te_symb(3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    integer :: branch
    complex(kind=8) :: tempb6
    complex(kind=8) :: tempb5(3)
    complex(kind=8) :: tempb4
    complex(kind=8) :: tempb3(3)
    complex(kind=8) :: tempb2
    complex(kind=8) :: tempb1(3)
    complex(kind=8) :: tempb0
    complex(kind=8) :: tempb(3)
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
    u(1) = cos(alpha*pi/180.)
    u(2) = 0.
    u(3) = sin(alpha*pi/180.)
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      call pushinteger4(el_loc_j)
      el_loc_j = (el_j-1)*(nx_-1)
      call pushcomplex16array(c_te, 3)
      c_te = mesh(nx_, el_j+1, :)
      call pushcomplex16array(d_te, 3)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          call pushinteger4(cp_loc)
          cp_loc = cp_i + cp_loc_j
          call pushcomplex16array(p, 3)
          p = points(cp_i, cp_j, :)
          call pushcomplex16array(r1, 3)
          r1 = p - d_te
          call pushcomplex16array(r2, 3)
          r2 = p - c_te
          call pushcomplex16(r1_mag)
          call normc(r1, r1_mag)
          call pushcomplex16(r2_mag)
          call normc(r2, r2_mag)
          call pushcomplex16array(ur2, 3)
          call crossc(u, r2, ur2)
          call pushcomplex16array(ur1, 3)
          call crossc(u, r1, ur1)
          call pushcomplex16(dot_ur2)
          call dotc(u, r2, dot_ur2)
          call pushcomplex16(dot_ur1)
          call dotc(u, r1, dot_ur1)
          if (symmetry) then
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            call pushcomplex16(r1_mag)
            call normc(r1, r1_mag)
            call pushcomplex16(r2_mag)
            call normc(r2, r2_mag)
            call pushcomplex16array(ur2, 3)
            call crossc(u, r2, ur2)
            call pushcomplex16array(ur1, 3)
            call crossc(u, r1, ur1)
            call pushcomplex16(dot_ur2)
            call dotc(u, r2, dot_ur2)
            call pushcomplex16(dot_ur1)
            call dotc(u, r1, dot_ur1)
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              call pushcomplex16array(c, 3)
              c = c_te
              call pushcomplex16array(d, 3)
              d = d_te
              call pushcontrol1b(0)
            else
              call pushcomplex16array(c, 3)
              c = bpts(el_i+1, el_j+1, :)
              call pushcomplex16array(d, 3)
              d = bpts(el_i+1, el_j+0, :)
              call pushcontrol1b(1)
            end if
            if (symmetry) then
              call pushcomplex16array(a_sym, 3)
              a_sym = a
              call pushcomplex16array(b_sym, 3)
              b_sym = b
              call pushcomplex16array(c_sym, 3)
              c_sym = c
              call pushcomplex16array(d_sym, 3)
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
            end if
            if (skip .and. cp_loc .eq. el_loc) then
              if (symmetry) then
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
              call pushcontrol1b(1)
            else
              if (symmetry) then
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
              call pushcontrol1b(0)
            end if
          end do
        end do
      end do
    end do
    pointsb = (0.0_4,0.0_4)
    meshb = (0.0_4,0.0_4)
    bptsb = (0.0_4,0.0_4)
    ub = (0.0_4,0.0_4)
    ur1b = (0.0_4,0.0_4)
    ur2b = (0.0_4,0.0_4)
    a_symb = (0.0_4,0.0_4)
    c_te_symb = (0.0_4,0.0_4)
    b_symb = (0.0_4,0.0_4)
    d_te_symb = (0.0_4,0.0_4)
    do el_j=ny_-1,1,-1
      c_teb = (0.0_4,0.0_4)
      d_teb = (0.0_4,0.0_4)
      do cp_j=ny-1,1,-1
        do cp_i=nx-1,1,-1
          pb = (0.0_4,0.0_4)
          edgesb = (0.0_4,0.0_4)
          do el_i=1,nx_-1,1
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              el_loc = el_i + el_loc_j
              boundb = (0.0_4,0.0_4)
              edgesb = edgesb + mtxb(cp_loc, el_loc, :)
              boundb = mtxb(cp_loc, el_loc, :)
              mtxb(cp_loc, el_loc, :) = (0.0_4,0.0_4)
              call popcontrol1b(branch)
              if (branch .eq. 0) call calc_vorticity_b(b_sym, b_symb, &
&                                                a_sym, a_symb, p, pb, &
&                                                bound, boundb)
              a = bpts(el_i+0, el_j+0, :)
              b = bpts(el_i+0, el_j+1, :)
              ab = (0.0_4,0.0_4)
              bb = (0.0_4,0.0_4)
              call calc_vorticity_b(a, ab, b, bb, p, pb, bound, boundb)
            else
              el_loc = el_i + el_loc_j
              boundb = (0.0_4,0.0_4)
              edgesb = edgesb + mtxb(cp_loc, el_loc, :)
              boundb = mtxb(cp_loc, el_loc, :)
              mtxb(cp_loc, el_loc, :) = (0.0_4,0.0_4)
              call popcontrol1b(branch)
              if (branch .eq. 0) call calc_vorticity_b(b_sym, b_symb, &
&                                                a_sym, a_symb, p, pb, &
&                                                bound, boundb)
              a = bpts(el_i+0, el_j+0, :)
              b = bpts(el_i+0, el_j+1, :)
              ab = (0.0_4,0.0_4)
              bb = (0.0_4,0.0_4)
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              d_symb = (0.0_4,0.0_4)
              call calc_vorticity_b(a_sym, a_symb, d_sym, d_symb, p, pb&
&                             , edges, edgesb)
              c_symb = (0.0_4,0.0_4)
              call calc_vorticity_b(c_sym, c_symb, b_sym, b_symb, p, pb&
&                             , edges, edgesb)
              d_symb(2) = -d_symb(2)
              c_symb(2) = -c_symb(2)
              b_symb(2) = -b_symb(2)
              a_symb(2) = -a_symb(2)
              db = (0.0_4,0.0_4)
              call popcomplex16array(d_sym, 3)
              db = d_symb
              cb = (0.0_4,0.0_4)
              call popcomplex16array(c_sym, 3)
              cb = c_symb
              call popcomplex16array(b_sym, 3)
              bb = bb + b_symb
              call popcomplex16array(a_sym, 3)
              ab = ab + a_symb
              a_symb = (0.0_4,0.0_4)
              b_symb = (0.0_4,0.0_4)
            else
              db = (0.0_4,0.0_4)
              cb = (0.0_4,0.0_4)
            end if
            call calc_vorticity_b(d, db, a, ab, p, pb, edges, edgesb)
            call calc_vorticity_b(b, bb, c, cb, p, pb, edges, edgesb)
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popcomplex16array(d, 3)
              d_teb = d_teb + db
              call popcomplex16array(c, 3)
              c_teb = c_teb + cb
            else
              call popcomplex16array(d, 3)
              bptsb(el_i+1, el_j+0, :) = bptsb(el_i+1, el_j+0, :) + db
              call popcomplex16array(c, 3)
              bptsb(el_i+1, el_j+1, :) = bptsb(el_i+1, el_j+1, :) + cb
            end if
            bptsb(el_i+0, el_j+1, :) = bptsb(el_i+0, el_j+1, :) + bb
            bptsb(el_i+0, el_j+0, :) = bptsb(el_i+0, el_j+0, :) + ab
          end do
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            tempb3 = edgesb/(r1_mag*(r1_mag-dot_ur1))
            tempb4 = sum(-(ur1*tempb3/(r1_mag*(r1_mag-dot_ur1))))
            ur1b = ur1b + tempb3
            r1_magb = (2*r1_mag-dot_ur1)*tempb4
            dot_ur1b = -(r1_mag*tempb4)
            tempb5 = -(edgesb/(r2_mag*(r2_mag-dot_ur2)))
            tempb6 = sum(-(ur2*tempb5/(r2_mag*(r2_mag-dot_ur2))))
            ur2b = ur2b + tempb5
            r2_magb = (2*r2_mag-dot_ur2)*tempb6
            dot_ur2b = -(r2_mag*tempb6)
            call popcomplex16(dot_ur1)
            r1b = (0.0_4,0.0_4)
            call dotc_b(u, ub, r1, r1b, dot_ur1, dot_ur1b)
            call popcomplex16(dot_ur2)
            r2b = (0.0_4,0.0_4)
            call dotc_b(u, ub, r2, r2b, dot_ur2, dot_ur2b)
            call popcomplex16array(ur1, 3)
            call crossc_b(u, ub, r1, r1b, ur1, ur1b)
            call popcomplex16array(ur2, 3)
            call crossc_b(u, ub, r2, r2b, ur2, ur2b)
            call popcomplex16(r2_mag)
            call normc_b(r2, r2b, r2_mag, r2_magb)
            call popcomplex16(r1_mag)
            call normc_b(r1, r1b, r1_mag, r1_magb)
            pb = pb + r1b + r2b
            c_te_symb = c_te_symb - r2b
            d_te_symb = d_te_symb - r1b
          end if
          tempb = -(edgesb/(r1_mag*(r1_mag-dot_ur1)))
          tempb0 = sum(-(ur1*tempb/(r1_mag*(r1_mag-dot_ur1))))
          ur1b = ur1b + tempb
          r1_magb = (2*r1_mag-dot_ur1)*tempb0
          dot_ur1b = -(r1_mag*tempb0)
          tempb1 = edgesb/(r2_mag*(r2_mag-dot_ur2))
          tempb2 = sum(-(ur2*tempb1/(r2_mag*(r2_mag-dot_ur2))))
          ur2b = ur2b + tempb1
          r2_magb = (2*r2_mag-dot_ur2)*tempb2
          dot_ur2b = -(r2_mag*tempb2)
          r1 = p - d_te
          call popcomplex16(dot_ur1)
          r1b = (0.0_4,0.0_4)
          call dotc_b(u, ub, r1, r1b, dot_ur1, dot_ur1b)
          r2 = p - c_te
          call popcomplex16(dot_ur2)
          r2b = (0.0_4,0.0_4)
          call dotc_b(u, ub, r2, r2b, dot_ur2, dot_ur2b)
          call popcomplex16array(ur1, 3)
          call crossc_b(u, ub, r1, r1b, ur1, ur1b)
          call popcomplex16array(ur2, 3)
          call crossc_b(u, ub, r2, r2b, ur2, ur2b)
          call popcomplex16(r2_mag)
          call normc_b(r2, r2b, r2_mag, r2_magb)
          call popcomplex16(r1_mag)
          call normc_b(r1, r1b, r1_mag, r1_magb)
          call popcomplex16array(r2, 3)
          pb = pb + r1b + r2b
          c_teb = c_teb - r2b
          call popcomplex16array(r1, 3)
          d_teb = d_teb - r1b
          call popcomplex16array(p, 3)
          pointsb(cp_i, cp_j, :) = pointsb(cp_i, cp_j, :) + pb
          call popinteger4(cp_loc)
        end do
      end do
      call popcontrol1b(branch)
      if (branch .ne. 0) then
        d_te_symb(2) = -d_te_symb(2)
        c_te_symb(2) = -c_te_symb(2)
        d_teb = d_teb + d_te_symb
        c_teb = c_teb + c_te_symb
        c_te_symb = (0.0_4,0.0_4)
        d_te_symb = (0.0_4,0.0_4)
      end if
      call popcomplex16array(d_te, 3)
      meshb(nx_, el_j+0, :) = meshb(nx_, el_j+0, :) + d_teb
      call popcomplex16array(c_te, 3)
      meshb(nx_, el_j+1, :) = meshb(nx_, el_j+1, :) + c_teb
      call popinteger4(el_loc_j)
    end do
    alphab = pi*cos(pi*(alpha/180.))*ub(3)/180.
    ub(3) = 0.0_8
    ub(2) = 0.0_8
    alphab = alphab - pi*sin(pi*(alpha/180.))*ub(1)/180.
    mtxb = (0.0_4,0.0_4)
  end subroutine assembleaeromtx_main_b
  subroutine assembleaeromtx_main(ny, nx, ny_, nx_, alpha, points, bpts&
&   , mesh, skip, symmetry, mtx)
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    complex(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    complex(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, &
&   ny_, 3)
    logical, intent(in) :: skip, symmetry
! output
    complex(kind=8), intent(out) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), &
&   3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    complex(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    complex(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    complex(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    complex(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    complex(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym&
&   (3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
    u(1) = cos(alpha*pi/180.)
    u(2) = 0.
    u(3) = sin(alpha*pi/180.)
    mtx(:, :, :) = 0.
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_te = mesh(nx_, el_j+1, :)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          p = points(cp_i, cp_j, :)
          r1 = p - d_te
          r2 = p - c_te
          call normc(r1, r1_mag)
          call normc(r2, r2_mag)
          call crossc(u, r2, ur2)
          call crossc(u, r1, ur1)
          edges(:) = 0.
          call dotc(u, r2, dot_ur2)
          call dotc(u, r1, dot_ur1)
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          if (symmetry) then
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            call normc(r1, r1_mag)
            call normc(r2, r2_mag)
            call crossc(u, r2, ur2)
            call crossc(u, r1, ur1)
            call dotc(u, r2, dot_ur2)
            call dotc(u, r1, dot_ur1)
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              c = c_te
              d = d_te
            else
              c = bpts(el_i+1, el_j+1, :)
              d = bpts(el_i+1, el_j+0, :)
            end if
            call calc_vorticity(b, c, p, edges)
            call calc_vorticity(d, a, p, edges)
            if (symmetry) then
              a_sym = a
              b_sym = b
              c_sym = c
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              call calc_vorticity(c_sym, b_sym, p, edges)
              call calc_vorticity(a_sym, d_sym, p, edges)
            end if
            if (skip .and. cp_loc .eq. el_loc) then
              bound(:) = 0.
              if (symmetry) call calc_vorticity(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            else
              bound(:) = 0.
              call calc_vorticity(a, b, p, bound)
              if (symmetry) call calc_vorticity(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            end if
          end do
        end do
      end do
    end do
  end subroutine assembleaeromtx_main
!  differentiation of calc_vorticity in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: p out a b
!   with respect to varying inputs: p out a b
  subroutine calc_vorticity_b(a, ab, b, bb, p, pb, out, outb)
    implicit none
! input
    complex(kind=8), intent(in) :: a(3), b(3), p(3)
    complex(kind=8) :: ab(3), bb(3), pb(3)
! output
    complex(kind=8), intent(inout) :: out(3)
    complex(kind=8) :: outb(3)
! working
    complex(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    complex(kind=8) :: r1b(3), r2b(3), r1_magb, r2_magb, r1r2b(3), &
&   mag_multb, dot_r1r2b
    complex(kind=8) :: tempb0
    complex(kind=8) :: tempb(3)
    r1 = p - a
    r2 = p - b
    call normc(r1, r1_mag)
    call normc(r2, r2_mag)
    call crossc(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    call dotc(r1, r2, dot_r1r2)
    r1r2b = (0.0_4,0.0_4)
    tempb = outb/(mag_mult*(mag_mult+dot_r1r2))
    tempb0 = sum(-((r1_mag+r2_mag)*r1r2*tempb/(mag_mult*(mag_mult+&
&     dot_r1r2))))
    r1r2b = (r1_mag+r2_mag)*tempb
    mag_multb = (2*mag_mult+dot_r1r2)*tempb0
    r1_magb = r2_mag*mag_multb + sum(r1r2*tempb)
    r2_magb = r1_mag*mag_multb + sum(r1r2*tempb)
    dot_r1r2b = mag_mult*tempb0
    r1b = (0.0_4,0.0_4)
    r2b = (0.0_4,0.0_4)
    call dotc_b(r1, r1b, r2, r2b, dot_r1r2, dot_r1r2b)
    call crossc_b(r1, r1b, r2, r2b, r1r2, r1r2b)
    call normc_b(r2, r2b, r2_mag, r2_magb)
    call normc_b(r1, r1b, r1_mag, r1_magb)
    pb = pb + r1b + r2b
    bb = bb - r2b
    ab = ab - r1b
  end subroutine calc_vorticity_b
  subroutine calc_vorticity(a, b, p, out)
    implicit none
! input
    complex(kind=8), intent(in) :: a(3), b(3), p(3)
! output
    complex(kind=8), intent(inout) :: out(3)
! working
    complex(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    r1 = p - a
    r2 = p - b
    call normc(r1, r1_mag)
    call normc(r2, r2_mag)
    call crossc(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    call dotc(r1, r2, dot_r1r2)
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  end subroutine calc_vorticity
  subroutine biotsavart(a, b, p, inf, rev, out)
    implicit none
! input
    complex(kind=8), intent(in) :: a(3), b(3), p(3)
    logical, intent(in) :: inf, rev
! output
    complex(kind=8), intent(inout) :: out(3)
! working
    complex(kind=8) :: rpa, rpb, rab, rh
    complex(kind=8) :: cosa, cosb, c(3)
    complex(kind=8) :: eps, tmp(3), dot_bapa, dot_baba, dot_pbab
    complex(kind=8), dimension(3) :: arg1
    complex(kind=8), dimension(3) :: arg2
    eps = 1e-5
    arg1(:) = a - p
    call normc(arg1(:), rpa)
    arg1(:) = b - p
    call normc(arg1(:), rpb)
    arg1(:) = b - a
    call normc(arg1(:), rab)
    arg1(:) = b - a
    arg2(:) = p - a
    call dotc(arg1(:), arg2(:), dot_bapa)
    arg1(:) = b - a
    arg2(:) = b - a
    call dotc(arg1(:), arg2(:), dot_baba)
    arg1(:) = p - b
    arg2(:) = a - b
    call dotc(arg1(:), arg2(:), dot_pbab)
    arg1(:) = p - a - dot_bapa/dot_baba*(b-a)
    call normc(arg1(:), rh)
    rh = rh + eps
    cosa = dot_bapa/(rpa*rab)
    cosb = dot_pbab/(rpb*rab)
    arg1(:) = b - p
    arg2(:) = a - p
    call crossc(arg1(:), arg2(:), c)
    call unitc(c, c)
    if (inf) then
      tmp = -(c/rh*(cosa+1))
    else
      tmp = -(c/rh*(cosa+cosb))
    end if
    if (rev) tmp = -tmp
    out = out + tmp
  end subroutine biotsavart
! complex functions
  subroutine unitc(v, u)
    implicit none
    complex(kind=8), intent(in) :: v(3)
    complex(kind=8), intent(out) :: u(3)
    complex(kind=8) :: nm
    call normc(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  end subroutine unitc
!  differentiation of normc in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: v norm_output
!   with respect to varying inputs: v
  subroutine normc_b(v, vb, norm_output, norm_outputb)
    implicit none
    complex(kind=8), intent(in) :: v(3)
    complex(kind=8) :: vb(3)
    complex(kind=8) :: norm_output
    complex(kind=8) :: norm_outputb
    complex(kind=8) :: dot_prod
    complex(kind=8) :: dot_prodb
!norm = sqrt(dot_product(v, v))
    call dotc(v, v, dot_prod)
    dot_prodb = 0.5*dot_prod**(-0.5)*norm_outputb
    call dotc_b(v, vb, v, vb, dot_prod, dot_prodb)
  end subroutine normc_b
  subroutine normc(v, norm_output)
    implicit none
    complex(kind=8), intent(in) :: v(3)
    complex(kind=8), intent(out) :: norm_output
    complex(kind=8) :: dot_prod
!norm = sqrt(dot_product(v, v))
    call dotc(v, v, dot_prod)
    norm_output = dot_prod**0.5
  end subroutine normc
!  differentiation of dotc in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: dot_prod a b
!   with respect to varying inputs: a b
  subroutine dotc_b(a, ab, b, bb, dot_prod, dot_prodb)
    implicit none
    complex(kind=8), intent(in) :: a(3), b(3)
    complex(kind=8) :: ab(3), bb(3)
    complex(kind=8) :: dot_prod
    complex(kind=8) :: dot_prodb
    ab(1) = ab(1) + b(1)*dot_prodb
    bb(1) = bb(1) + a(1)*dot_prodb
    ab(2) = ab(2) + b(2)*dot_prodb
    bb(2) = bb(2) + a(2)*dot_prodb
    ab(3) = ab(3) + b(3)*dot_prodb
    bb(3) = bb(3) + a(3)*dot_prodb
  end subroutine dotc_b
  subroutine dotc(a, b, dot_prod)
    implicit none
    complex(kind=8), intent(in) :: a(3), b(3)
    complex(kind=8), intent(out) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dotc
!  differentiation of crossc in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b c
  subroutine crossc_b(a, ab, b, bb, c, cb)
    implicit none
    complex(kind=8), intent(in) :: a(3), b(3)
    complex(kind=8) :: ab(3), bb(3)
    complex(kind=8) :: c(3)
    complex(kind=8) :: cb(3)
    ab(1) = ab(1) + b(2)*cb(3)
    bb(2) = bb(2) + a(1)*cb(3)
    ab(2) = ab(2) - b(1)*cb(3)
    bb(1) = bb(1) - a(2)*cb(3)
    cb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*cb(2)
    bb(1) = bb(1) + a(3)*cb(2)
    ab(1) = ab(1) - b(3)*cb(2)
    bb(3) = bb(3) - a(1)*cb(2)
    cb(2) = 0.0_8
    ab(2) = ab(2) + b(3)*cb(1)
    bb(3) = bb(3) + a(2)*cb(1)
    ab(3) = ab(3) - b(2)*cb(1)
    bb(2) = bb(2) - a(3)*cb(1)
    cb(1) = 0.0_8
  end subroutine crossc_b
  subroutine crossc(a, b, c)
    implicit none
    complex(kind=8), intent(in) :: a(3), b(3)
    complex(kind=8), intent(out) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine crossc
!  differentiation of unit in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
! real functions
  subroutine unit_b(v, vb, u, ub)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8) :: vb(3)
    real(kind=8) :: u(3)
    real(kind=8) :: ub(3)
    real(kind=8) :: nm
    real(kind=8) :: nmb
    call norm(v, nm)
    vb(3) = vb(3) + ub(3)/nm
    nmb = -(v(3)*ub(3)/nm**2)
    ub(3) = 0.0_8
    vb(2) = vb(2) + ub(2)/nm
    nmb = nmb - v(2)*ub(2)/nm**2
    ub(2) = 0.0_8
    vb(1) = vb(1) + ub(1)/nm
    nmb = nmb - v(1)*ub(1)/nm**2
    ub(1) = 0.0_8
    call norm_b(v, vb, nm, nmb)
  end subroutine unit_b
! real functions
  subroutine unit(v, u)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: u(3)
    real(kind=8) :: nm
    call norm(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  end subroutine unit
!  differentiation of norm in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: v norm_output
!   with respect to varying inputs: v
  subroutine norm_b(v, vb, norm_output, norm_outputb)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8) :: vb(3)
    real(kind=8) :: norm_output
    real(kind=8) :: norm_outputb
    real(kind=8) :: dot_prod
    real(kind=8) :: dot_prodb
!norm = sqrt(dot_product(v, v))
    call dot(v, v, dot_prod)
    dot_prodb = 0.5*dot_prod**(-0.5)*norm_outputb
    call dot_b(v, vb, v, vb, dot_prod, dot_prodb)
  end subroutine norm_b
  subroutine norm(v, norm_output)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: norm_output
    real(kind=8) :: dot_prod
!norm = sqrt(dot_product(v, v))
    call dot(v, v, dot_prod)
    norm_output = dot_prod**0.5
  end subroutine norm
!  differentiation of dot in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: dot_prod a b
!   with respect to varying inputs: a b
  subroutine dot_b(a, ab, b, bb, dot_prod, dot_prodb)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8) :: ab(3), bb(3)
    real(kind=8) :: dot_prod
    real(kind=8) :: dot_prodb
    ab(1) = ab(1) + b(1)*dot_prodb
    bb(1) = bb(1) + a(1)*dot_prodb
    ab(2) = ab(2) + b(2)*dot_prodb
    bb(2) = bb(2) + a(2)*dot_prodb
    ab(3) = ab(3) + b(3)*dot_prodb
    bb(3) = bb(3) + a(3)*dot_prodb
  end subroutine dot_b
  subroutine dot(a, b, dot_prod)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot
!  differentiation of cross in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b c
  subroutine cross_b(a, ab, b, bb, c, cb)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8) :: ab(3), bb(3)
    real(kind=8) :: c(3)
    real(kind=8) :: cb(3)
    ab(1) = ab(1) + b(2)*cb(3)
    bb(2) = bb(2) + a(1)*cb(3)
    ab(2) = ab(2) - b(1)*cb(3)
    bb(1) = bb(1) - a(2)*cb(3)
    cb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*cb(2)
    bb(1) = bb(1) + a(3)*cb(2)
    ab(1) = ab(1) - b(3)*cb(2)
    bb(3) = bb(3) - a(1)*cb(2)
    cb(2) = 0.0_8
    ab(2) = ab(2) + b(3)*cb(1)
    bb(3) = bb(3) + a(2)*cb(1)
    ab(3) = ab(3) - b(2)*cb(1)
    bb(2) = bb(2) - a(3)*cb(1)
    cb(1) = 0.0_8
  end subroutine cross_b
  subroutine cross(a, b, c)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross
end module oas_main_b
