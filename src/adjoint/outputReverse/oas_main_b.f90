!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module oas_main_b
  implicit none

contains
  subroutine mult(nx, ny, x, y)
    implicit none
    integer, intent(in) :: nx, ny
    real*8, intent(in) :: x(nx)
    real*8, intent(out) :: y(ny)
    integer :: i, j
    y(:) = 0.
    do j=1,ny
      do i=1,nx
        y(j) = y(j) + x(i)**2
      end do
    end do
  end subroutine mult
!  differentiation of assemblesparsemtx_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: data
!   with respect to varying inputs: data nodes
!   rw status of diff variables: data:in-zero nodes:out
  subroutine assemblesparsemtx_main_b(num_elems, tot_n_fem, nnz, x_gl, e&
&   , g, a, j, iy, iz, nodes, nodesb, elems, coeff_at, coeff_y, coeff_z&
&   , pelem_a, pelem_t, pelem_y, pelem_z, data, datab, rows, cols)
    implicit none
! input
    integer, intent(in) :: tot_n_fem, num_elems, nnz
    real(kind=8), intent(in) :: x_gl(3)
    real(kind=8) :: x_glb(3)
    real(kind=8), intent(in) :: e(num_elems), g(num_elems)
    real(kind=8), intent(in) :: a(num_elems), j(num_elems)
    real(kind=8), intent(in) :: iy(num_elems), iz(num_elems)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3)
    real(kind=8) :: nodesb(tot_n_fem, 3)
    integer, intent(in) :: elems(num_elems, 2)
! local stiffness matrix coefficients
    real(kind=8), intent(in) :: coeff_at(2, 2), coeff_y(4, 4), coeff_z(4&
&   , 4)
! local permutation matrices to map to list of dofs for local element
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12)
    real(kind=8) :: pelem_ab(2, 12), pelem_tb(2, 12)
    real(kind=8), intent(in) :: pelem_y(4, 12), pelem_z(4, 12)
    real(kind=8) :: pelem_yb(4, 12), pelem_zb(4, 12)
! output
    real(kind=8) :: data(nnz)
    real(kind=8) :: datab(nnz)
    integer, intent(out) :: rows(nnz), cols(nnz)
! local stiffness matrices for axial, torsion, bending (y,z)
    real(kind=8) :: kelem_a(2, 2), kelem_t(2, 2)
    real(kind=8) :: kelem_ab(2, 2), kelem_tb(2, 2)
    real(kind=8) :: kelem_y(4, 4), kelem_z(4, 4)
    real(kind=8) :: kelem_yb(4, 4), kelem_zb(4, 4)
! local transformation matrix (12,12) to map from local to global frame
    real(kind=8) :: t_elem(12, 12), t(3, 3)
    real(kind=8) :: t_elemb(12, 12), tb(3, 3)
! arrays that help in mapping from local element ordering to global ordering
    integer :: rows_elem(12, 12), cols_elem(12, 12)
    integer :: ones11(12, 12), ones12(12, 12)
    integer :: ones21(12, 12), ones22(12, 12)
! local stiffness matrix in global frame
    real(kind=8) :: k_elem(12, 12)
    real(kind=8) :: k_elemb(12, 12)
! miscellaneous
    real(kind=8) :: l, xyz1(3), xyz2(3)
    real(kind=8) :: lb, xyz1b(3), xyz2b(3)
    real(kind=8) :: x_loc(3), y_loc(3), z_loc(3), x_cross(3), y_cross(3)
    real(kind=8) :: x_locb(3), y_locb(3), z_locb(3), x_crossb(3), &
&   y_crossb(3)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2), &
&   res(12, 12)
    real(kind=8) :: mat12x12b(12, 12), mat12x4b(12, 4), mat12x2b(12, 2)&
&   , resb(12, 12)
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2)
    real(kind=8) :: pelem_a_tb(12, 2), pelem_t_tb(12, 2)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)
    real(kind=8) :: pelem_y_tb(12, 4), pelem_z_tb(12, 4), t_elem_tb(12, &
&   12)
    integer :: i, k1, k2, ind, ind1, ind2, ielem
    intrinsic mod
    real(kind=8), dimension(3) :: arg1
    real(kind=8), dimension(3) :: arg1b
    real(kind=8) :: temp0
    real(kind=8) :: temp
    t_elem(:, :) = 0.
    ind = 0
    do ielem=1,num_elems
      xyz1 = nodes(elems(ielem, 1), :)
      xyz2 = nodes(elems(ielem, 2), :)
      arg1(:) = xyz2 - xyz1
      call pushreal8(l)
      call norm(arg1(:), l)
      arg1(:) = xyz2 - xyz1
      call pushreal8array(x_loc, 3)
      call unit(arg1(:), x_loc)
      call pushreal8array(x_cross, 3)
      call cross(x_loc, x_gl, x_cross)
      call pushreal8array(y_loc, 3)
      call unit(x_cross, y_loc)
      call pushreal8array(y_cross, 3)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do i=1,4
        call pushreal8array(t_elem(3*(i-1)+1:3*(i-1)+3, 3*(i-1)+1:3*(i-1&
&                     )+3), 3**2)
        t_elem(3*(i-1)+1:3*(i-1)+3, 3*(i-1)+1:3*(i-1)+3) = t
      end do
      kelem_a = coeff_at*e(ielem)*a(ielem)/l
      kelem_t = coeff_at*g(ielem)*j(ielem)/l
      call pushreal8array(kelem_y, 4**2)
      kelem_y = coeff_y*e(ielem)*iy(ielem)/l**3
      call pushreal8array(kelem_y(2:4:2, :), 2*4)
      kelem_y(2:4:2, :) = kelem_y(2:4:2, :)*l
      call pushreal8array(kelem_y(:, 2:4:2), 4*2)
      kelem_y(:, 2:4:2) = kelem_y(:, 2:4:2)*l
      call pushreal8array(kelem_z, 4**2)
      kelem_z = coeff_z*e(ielem)*iz(ielem)/l**3
      call pushreal8array(kelem_z(2:4:2, :), 2*4)
      kelem_z(2:4:2, :) = kelem_z(2:4:2, :)*l
      call pushreal8array(kelem_z(:, 2:4:2), 4*2)
      kelem_z(:, 2:4:2) = kelem_z(:, 2:4:2)*l
      call pushreal8array(k_elem, 12**2)
      k_elem(:, :) = 0.
      call pushreal8array(pelem_a_t, 12*2)
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call pushreal8array(mat12x2, 12*2)
      call matmul2(12, 2, 2, pelem_a_t, kelem_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_t_t, 12*2)
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call pushreal8array(mat12x2, 12*2)
      call matmul2(12, 2, 2, pelem_t_t, kelem_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_y_t, 12*4)
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call pushreal8array(mat12x4, 12*4)
      call matmul2(12, 4, 4, pelem_y_t, kelem_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_z_t, 12*4)
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call pushreal8array(mat12x4, 12*4)
      call matmul2(12, 4, 4, pelem_z_t, kelem_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call pushreal8array(t_elem_t, 12**2)
      call transpose2(12, 12, t_elem, t_elem_t)
      call pushreal8array(mat12x12, 12**2)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      do k1=1,12
        do k2=1,12
          call pushinteger4(ind)
          ind = ind + 1
        end do
      end do
    end do
    nodesb = 0.0_8
    y_locb = 0.0_8
    tb = 0.0_8
    t_elemb = 0.0_8
    z_locb = 0.0_8
    t_elem_tb = 0.0_8
    y_crossb = 0.0_8
    x_crossb = 0.0_8
    x_locb = 0.0_8
    do ielem=num_elems,1,-1
      k_elemb = 0.0_8
      do k1=12,1,-1
        do k2=12,1,-1
          k_elemb(k1, k2) = k_elemb(k1, k2) + datab(ind)
          call popinteger4(ind)
        end do
      end do
      mat12x12b = 0.0_8
      call matmul2_b(12, 12, 12, mat12x12, mat12x12b, t_elem, t_elemb, &
&              k_elem, k_elemb)
      call popreal8array(mat12x12, 12**2)
      k_elemb = 0.0_8
      call matmul2_b(12, 12, 12, t_elem_t, t_elem_tb, k_elem, k_elemb, &
&              mat12x12, mat12x12b)
      call popreal8array(t_elem_t, 12**2)
      call transpose2_b(12, 12, t_elem, t_elemb, t_elem_t, t_elem_tb)
      resb = 0.0_8
      resb = k_elemb
      mat12x4b = 0.0_8
      pelem_zb = 0.0_8
      call matmul2_b(12, 4, 12, mat12x4, mat12x4b, pelem_z, pelem_zb, &
&              res, resb)
      call popreal8array(mat12x4, 12*4)
      pelem_z_tb = 0.0_8
      kelem_zb = 0.0_8
      call matmul2_b(12, 4, 4, pelem_z_t, pelem_z_tb, kelem_z, kelem_zb&
&              , mat12x4, mat12x4b)
      call popreal8array(pelem_z_t, 12*4)
      resb = 0.0_8
      resb = k_elemb
      mat12x4b = 0.0_8
      pelem_yb = 0.0_8
      call matmul2_b(12, 4, 12, mat12x4, mat12x4b, pelem_y, pelem_yb, &
&              res, resb)
      call popreal8array(mat12x4, 12*4)
      pelem_y_tb = 0.0_8
      kelem_yb = 0.0_8
      call matmul2_b(12, 4, 4, pelem_y_t, pelem_y_tb, kelem_y, kelem_yb&
&              , mat12x4, mat12x4b)
      call popreal8array(pelem_y_t, 12*4)
      resb = 0.0_8
      resb = k_elemb
      mat12x2b = 0.0_8
      pelem_tb = 0.0_8
      call matmul2_b(12, 2, 12, mat12x2, mat12x2b, pelem_t, pelem_tb, &
&              res, resb)
      kelem_t = coeff_at*g(ielem)*j(ielem)/l
      call popreal8array(mat12x2, 12*2)
      pelem_t_tb = 0.0_8
      kelem_tb = 0.0_8
      call matmul2_b(12, 2, 2, pelem_t_t, pelem_t_tb, kelem_t, kelem_tb&
&              , mat12x2, mat12x2b)
      call popreal8array(pelem_t_t, 12*2)
      resb = 0.0_8
      resb = k_elemb
      mat12x2b = 0.0_8
      pelem_ab = 0.0_8
      call matmul2_b(12, 2, 12, mat12x2, mat12x2b, pelem_a, pelem_ab, &
&              res, resb)
      kelem_a = coeff_at*e(ielem)*a(ielem)/l
      call popreal8array(mat12x2, 12*2)
      pelem_a_tb = 0.0_8
      kelem_ab = 0.0_8
      call matmul2_b(12, 2, 2, pelem_a_t, pelem_a_tb, kelem_a, kelem_ab&
&              , mat12x2, mat12x2b)
      call popreal8array(pelem_a_t, 12*2)
      call popreal8array(k_elem, 12**2)
      call popreal8array(kelem_z(:, 2:4:2), 4*2)
      lb = sum(kelem_z(:, 2:4:2)*kelem_zb(:, 2:4:2))
      kelem_zb(:, 2:4:2) = l*kelem_zb(:, 2:4:2)
      call popreal8array(kelem_z(2:4:2, :), 2*4)
      lb = lb + sum(kelem_z(2:4:2, :)*kelem_zb(2:4:2, :))
      kelem_zb(2:4:2, :) = l*kelem_zb(2:4:2, :)
      call popreal8array(kelem_z, 4**2)
      temp0 = l**3
      call popreal8array(kelem_y(:, 2:4:2), 4*2)
      lb = lb + sum(kelem_y(:, 2:4:2)*kelem_yb(:, 2:4:2)) + 3*l**2*sum(-&
&       (coeff_z*e(ielem)*iz(ielem)*kelem_zb/temp0))/temp0
      kelem_yb(:, 2:4:2) = l*kelem_yb(:, 2:4:2)
      call popreal8array(kelem_y(2:4:2, :), 2*4)
      lb = lb + sum(kelem_y(2:4:2, :)*kelem_yb(2:4:2, :))
      kelem_yb(2:4:2, :) = l*kelem_yb(2:4:2, :)
      call popreal8array(kelem_y, 4**2)
      temp = l**3
      lb = lb + g(ielem)*j(ielem)*sum(-(coeff_at*kelem_tb/l))/l + e(&
&       ielem)*a(ielem)*sum(-(coeff_at*kelem_ab/l))/l + 3*l**2*sum(-(&
&       coeff_y*e(ielem)*iy(ielem)*kelem_yb/temp))/temp
      do i=4,1,-1
        call popreal8array(t_elem(3*(i-1)+1:3*(i-1)+3, 3*(i-1)+1:3*(i-1)&
&                    +3), 3**2)
        tb = tb + t_elemb(3*(i-1)+1:3*(i-1)+3, 3*(i-1)+1:3*(i-1)+3)
        t_elemb(3*(i-1)+1:3*(i-1)+3, 3*(i-1)+1:3*(i-1)+3) = 0.0_8
      end do
      z_locb = z_locb + tb(3, :)
      tb(3, :) = 0.0_8
      y_locb = y_locb + tb(2, :)
      tb(2, :) = 0.0_8
      x_locb = x_locb + tb(1, :)
      tb(1, :) = 0.0_8
      call unit_b(y_cross, y_crossb, z_loc, z_locb)
      call popreal8array(y_cross, 3)
      call cross_b(x_loc, x_locb, y_loc, y_locb, y_cross, y_crossb)
      call popreal8array(y_loc, 3)
      call unit_b(x_cross, x_crossb, y_loc, y_locb)
      call popreal8array(x_cross, 3)
      x_glb = 0.0_8
      call cross_b(x_loc, x_locb, x_gl, x_glb, x_cross, x_crossb)
      xyz1 = nodes(elems(ielem, 1), :)
      xyz2 = nodes(elems(ielem, 2), :)
      arg1(:) = xyz2 - xyz1
      call popreal8array(x_loc, 3)
      arg1b = 0.0_8
      call unit_b(arg1(:), arg1b(:), x_loc, x_locb)
      xyz1b = 0.0_8
      xyz2b = 0.0_8
      xyz2b = arg1b(:)
      xyz1b = -arg1b(:)
      arg1(:) = xyz2 - xyz1
      call popreal8(l)
      arg1b = 0.0_8
      call norm_b(arg1(:), arg1b(:), l, lb)
      xyz2b = xyz2b + arg1b
      xyz1b = xyz1b - arg1b
      nodesb(elems(ielem, 2), :) = nodesb(elems(ielem, 2), :) + xyz2b
      nodesb(elems(ielem, 1), :) = nodesb(elems(ielem, 1), :) + xyz1b
    end do
    datab = 0.0_8
  end subroutine assemblesparsemtx_main_b
  subroutine assemblesparsemtx_main(num_elems, tot_n_fem, nnz, x_gl, e, &
&   g, a, j, iy, iz, nodes, elems, coeff_at, coeff_y, coeff_z, pelem_a, &
&   pelem_t, pelem_y, pelem_z, data, rows, cols)
    implicit none
! input
    integer, intent(in) :: tot_n_fem, num_elems, nnz
    real(kind=8), intent(in) :: x_gl(3)
    real(kind=8), intent(in) :: e(num_elems), g(num_elems)
    real(kind=8), intent(in) :: a(num_elems), j(num_elems)
    real(kind=8), intent(in) :: iy(num_elems), iz(num_elems)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3)
    integer, intent(in) :: elems(num_elems, 2)
! local stiffness matrix coefficients
    real(kind=8), intent(in) :: coeff_at(2, 2), coeff_y(4, 4), coeff_z(4&
&   , 4)
! local permutation matrices to map to list of dofs for local element
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12)
    real(kind=8), intent(in) :: pelem_y(4, 12), pelem_z(4, 12)
! output
    real(kind=8), intent(out) :: data(nnz)
    integer, intent(out) :: rows(nnz), cols(nnz)
! local stiffness matrices for axial, torsion, bending (y,z)
    real(kind=8) :: kelem_a(2, 2), kelem_t(2, 2)
    real(kind=8) :: kelem_y(4, 4), kelem_z(4, 4)
! local transformation matrix (12,12) to map from local to global frame
    real(kind=8) :: t_elem(12, 12), t(3, 3)
! arrays that help in mapping from local element ordering to global ordering
    integer :: rows_elem(12, 12), cols_elem(12, 12)
    integer :: ones11(12, 12), ones12(12, 12)
    integer :: ones21(12, 12), ones22(12, 12)
! local stiffness matrix in global frame
    real(kind=8) :: k_elem(12, 12)
! miscellaneous
    real(kind=8) :: l, xyz1(3), xyz2(3)
    real(kind=8) :: x_loc(3), y_loc(3), z_loc(3), x_cross(3), y_cross(3)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2), &
&   res(12, 12)
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)
    integer :: i, k1, k2, ind, ind1, ind2, ielem
    intrinsic mod
    real(kind=8), dimension(3) :: arg1
    do k1=1,12
      do k2=1,12
        rows_elem(k1, k2) = mod(k1 - 1, 6)
        cols_elem(k1, k2) = mod(k2 - 1, 6)
      end do
    end do
    ones11(:, :) = 0
    ones12(:, :) = 0
    ones21(:, :) = 0
    ones22(:, :) = 0
    ones11(1:6, 1:6) = 1
    ones12(1:6, 7:12) = 1
    ones21(7:12, 1:6) = 1
    ones22(7:12, 7:12) = 1
    t_elem(:, :) = 0.
    data(:) = 0.
    rows(:) = 0
    cols(:) = 0
    ind = 0
    do ielem=1,num_elems
      xyz1 = nodes(elems(ielem, 1), :)
      xyz2 = nodes(elems(ielem, 2), :)
      arg1(:) = xyz2 - xyz1
      call norm(arg1(:), l)
      arg1(:) = xyz2 - xyz1
      call unit(arg1(:), x_loc)
      call cross(x_loc, x_gl, x_cross)
      call unit(x_cross, y_loc)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do i=1,4
        t_elem(3*(i-1)+1:3*(i-1)+3, 3*(i-1)+1:3*(i-1)+3) = t
      end do
      kelem_a = coeff_at*e(ielem)*a(ielem)/l
      kelem_t = coeff_at*g(ielem)*j(ielem)/l
      kelem_y = coeff_y*e(ielem)*iy(ielem)/l**3
      kelem_y(2:4:2, :) = kelem_y(2:4:2, :)*l
      kelem_y(:, 2:4:2) = kelem_y(:, 2:4:2)*l
      kelem_z = coeff_z*e(ielem)*iz(ielem)/l**3
      kelem_z(2:4:2, :) = kelem_z(2:4:2, :)*l
      kelem_z(:, 2:4:2) = kelem_z(:, 2:4:2)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call matmul2(12, 2, 2, pelem_a_t, kelem_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call matmul2(12, 2, 2, pelem_t_t, kelem_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call matmul2(12, 4, 4, pelem_y_t, kelem_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call matmul2(12, 4, 4, pelem_z_t, kelem_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call transpose2(12, 12, t_elem, t_elem_t)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      call matmul2(12, 12, 12, mat12x12, t_elem, k_elem)
      ind1 = 6*(elems(ielem, 1)-1)
      ind2 = 6*(elems(ielem, 2)-1)
      do k1=1,12
        do k2=1,12
          ind = ind + 1
          data(ind) = data(ind) + k_elem(k1, k2)
          rows(ind) = rows(ind) + rows_elem(k1, k2) + 1
          cols(ind) = cols(ind) + cols_elem(k1, k2) + 1
          rows(ind) = rows(ind) + ones11(k1, k2)*ind1
          cols(ind) = cols(ind) + ones11(k1, k2)*ind1
          rows(ind) = rows(ind) + ones12(k1, k2)*ind1
          cols(ind) = cols(ind) + ones12(k1, k2)*ind2
          rows(ind) = rows(ind) + ones21(k1, k2)*ind2
          cols(ind) = cols(ind) + ones21(k1, k2)*ind1
          rows(ind) = rows(ind) + ones22(k1, k2)*ind2
          cols(ind) = cols(ind) + ones22(k1, k2)*ind2
        end do
      end do
    end do
    if (ind .ne. nnz) print*, &
&         'error in assemblesparsemtx: did not reach end of nnz vectors'
    rows(:) = rows(:) - 1
    cols(:) = cols(:) - 1
  end subroutine assemblesparsemtx_main
!  differentiation of assemblestructmtx_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: x
!   with respect to varying inputs: j x nodes iy iz rhs a
!   rw status of diff variables: j:out k:(loc) x:in-out nodes:out
!                iy:out iz:out rhs:out a:out
! 6
! 4
! 3
! 3
! 6
  subroutine assemblestructmtx_main_b(n, tot_n_fem, size, nodes, nodesb&
&   , a, ab, j, jb, iy, iyb, iz, izb, k_a, k_t, k_y, k_z, elem_ids, cons&
&   , e, g, x_gl, t, k_elem, pelem_a, pelem_t, pelem_y, pelem_z, t_elem&
&   , const2, const_y, const_z, rhs, rhsb, k, kb, x, xb)
! 7
    use solveroutines, only : solve_b
    implicit none
! input
    integer, intent(in) :: n, size, cons, tot_n_fem
    integer, intent(inout) :: elem_ids(n-1, 2)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8) :: nodesb(tot_n_fem, 3), ab(n-1), jb(n-1), iyb(n-1), &
&   izb(n-1)
    real(kind=8), intent(in) :: e(n-1), g(n-1), x_gl(3)
    real(kind=8) :: x_glb(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8) :: pelem_ab(2, 12), pelem_tb(2, 12), pelem_yb(4, 12), &
&   pelem_zb(4, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4), rhs(size)
    real(kind=8) :: rhsb(size)
! output
    real(kind=8) :: x(size), k(size, size)
    real(kind=8) :: xb(size), kb(size, size)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: p0b(3), p1b(3), x_locb(3), y_locb(3), z_locb(3), &
&   x_crossb(3), y_crossb(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: lb, ea_lb, gj_lb, eiy_l3b, eiz_l3b, resb(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    real(kind=8) :: mat12x12b(12, 12), mat12x4b(12, 4), mat12x2b(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(size, size)
    real(kind=8) :: pelem_a_tb(12, 2), pelem_t_tb(12, 2), k_b(size, size&
&   )
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)&
&   , b(size)
    real(kind=8) :: pelem_y_tb(12, 4), pelem_z_tb(12, 4), t_elem_tb(12, &
&   12), bb(size)
    integer :: ipiv(size), n_solve
    real(kind=8), dimension(3) :: arg1
    real(kind=8), dimension(3) :: arg1b
    real(kind=8) :: temp0
    real(kind=8) :: tb(3, 3)
    real(kind=8) :: k_elemb(12, 12)
    real(kind=8) :: k_yb(4, 4)
    real(kind=8) :: tempb2
    real(kind=8) :: tempb1
    real(kind=8) :: tempb0
    real(kind=8) :: tempb
    real(kind=8) :: k_ab(2, 2)
    real(kind=8) :: t_elemb(12, 12)
    real(kind=8) :: k_tb(2, 2)
    real(kind=8) :: k_zb(4, 4)
    real(kind=8) :: temp
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    k(:, :) = 0.
! loop over num elements
    do ielem=1,num_elems
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      arg1(:) = p1 - p0
      call pushreal8array(x_loc, 3)
      call unit(arg1(:), x_loc)
      call pushreal8array(x_cross, 3)
      call cross(x_loc, x_gl, x_cross)
      call pushreal8array(y_loc, 3)
      call unit(x_cross, y_loc)
      call pushreal8array(y_cross, 3)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do ind=1,4
        call pushreal8array(t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:&
&                     3*(ind-1)+3), 3**2)
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      arg1(:) = p1 - p0
      call pushreal8(l)
      call norm(arg1(:), l)
      ea_l = e(ielem)*a(ielem)/l
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      call pushreal8array(k_y, 4**2)
      k_y(:, :) = eiy_l3*const_y
      call pushreal8array(k_y(2, :), 4)
      k_y(2, :) = k_y(2, :)*l
      call pushreal8array(k_y(4, :), 4)
      k_y(4, :) = k_y(4, :)*l
      call pushreal8array(k_y(:, 2), 4)
      k_y(:, 2) = k_y(:, 2)*l
      call pushreal8array(k_y(:, 4), 4)
      k_y(:, 4) = k_y(:, 4)*l
      call pushreal8array(k_z, 4**2)
      k_z(:, :) = eiz_l3*const_z
      call pushreal8array(k_z(2, :), 4)
      k_z(2, :) = k_z(2, :)*l
      call pushreal8array(k_z(4, :), 4)
      k_z(4, :) = k_z(4, :)*l
      call pushreal8array(k_z(:, 2), 4)
      k_z(:, 2) = k_z(:, 2)*l
      call pushreal8array(k_z(:, 4), 4)
      k_z(:, 4) = k_z(:, 4)*l
      call pushreal8array(k_elem, 12**2)
      k_elem(:, :) = 0.
      call pushreal8array(pelem_a_t, 12*2)
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call pushreal8array(mat12x2, 12*2)
      call matmul2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_t_t, 12*2)
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call pushreal8array(mat12x2, 12*2)
      call matmul2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_y_t, 12*4)
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call pushreal8array(mat12x4, 12*4)
      call matmul2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_z_t, 12*4)
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call pushreal8array(mat12x4, 12*4)
      call matmul2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call pushreal8array(t_elem_t, 12**2)
      call transpose2(12, 12, t_elem, t_elem_t)
      call pushreal8array(mat12x12, 12**2)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      call matmul2(12, 12, 12, mat12x12, t_elem, res)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
    n_solve = size
    b = rhs
    k_ = k
    k_b = 0.0_8
    bb = 0.0_8
    call solve_b(k_, k_b, x, xb, b, bb, n_solve, ipiv)
    kb = 0.0_8
    kb = k_b
    rhsb = 0.0_8
    rhsb = bb
    do i=6,1,-1
      kb(6*cons+i, 6*num_nodes+i) = 0.0_8
      kb(6*num_nodes+i, 6*cons+i) = 0.0_8
    end do
    jb = 0.0_8
    tb = 0.0_8
    t_elemb = 0.0_8
    nodesb = 0.0_8
    iyb = 0.0_8
    izb = 0.0_8
    ab = 0.0_8
    y_locb = 0.0_8
    z_locb = 0.0_8
    t_elem_tb = 0.0_8
    y_crossb = 0.0_8
    x_crossb = 0.0_8
    x_locb = 0.0_8
    do ielem=num_elems,1,-1
      in1 = elem_ids(ielem, 2)
      resb = 0.0_8
      resb(7:12, 7:12) = resb(7:12, 7:12) + kb(6*(in1-1)+1:6*(in1-1)+6, &
&       6*(in1-1)+1:6*(in1-1)+6)
      in0 = elem_ids(ielem, 1)
      resb(1:6, 7:12) = resb(1:6, 7:12) + kb(6*(in0-1)+1:6*(in0-1)+6, 6*&
&       (in1-1)+1:6*(in1-1)+6)
      resb(7:12, 1:6) = resb(7:12, 1:6) + kb(6*(in1-1)+1:6*(in1-1)+6, 6*&
&       (in0-1)+1:6*(in0-1)+6)
      resb(1:6, 1:6) = resb(1:6, 1:6) + kb(6*(in0-1)+1:6*(in0-1)+6, 6*(&
&       in0-1)+1:6*(in0-1)+6)
      mat12x12b = 0.0_8
      call matmul2_b(12, 12, 12, mat12x12, mat12x12b, t_elem, t_elemb, &
&              res, resb)
      call popreal8array(mat12x12, 12**2)
      k_elemb = 0.0_8
      call matmul2_b(12, 12, 12, t_elem_t, t_elem_tb, k_elem, k_elemb, &
&              mat12x12, mat12x12b)
      call popreal8array(t_elem_t, 12**2)
      call transpose2_b(12, 12, t_elem, t_elemb, t_elem_t, t_elem_tb)
      resb = 0.0_8
      resb = k_elemb
      mat12x4b = 0.0_8
      pelem_zb = 0.0_8
      call matmul2_b(12, 4, 12, mat12x4, mat12x4b, pelem_z, pelem_zb, &
&              res, resb)
      call popreal8array(mat12x4, 12*4)
      pelem_z_tb = 0.0_8
      k_zb = 0.0_8
      call matmul2_b(12, 4, 4, pelem_z_t, pelem_z_tb, k_z, k_zb, mat12x4&
&              , mat12x4b)
      call popreal8array(pelem_z_t, 12*4)
      resb = 0.0_8
      resb = k_elemb
      mat12x4b = 0.0_8
      pelem_yb = 0.0_8
      call matmul2_b(12, 4, 12, mat12x4, mat12x4b, pelem_y, pelem_yb, &
&              res, resb)
      call popreal8array(mat12x4, 12*4)
      pelem_y_tb = 0.0_8
      k_yb = 0.0_8
      call matmul2_b(12, 4, 4, pelem_y_t, pelem_y_tb, k_y, k_yb, mat12x4&
&              , mat12x4b)
      call popreal8array(pelem_y_t, 12*4)
      resb = 0.0_8
      resb = k_elemb
      mat12x2b = 0.0_8
      pelem_tb = 0.0_8
      call matmul2_b(12, 2, 12, mat12x2, mat12x2b, pelem_t, pelem_tb, &
&              res, resb)
      gj_l = g(ielem)*j(ielem)/l
      k_t(:, :) = gj_l*const2
      call popreal8array(mat12x2, 12*2)
      pelem_t_tb = 0.0_8
      k_tb = 0.0_8
      call matmul2_b(12, 2, 2, pelem_t_t, pelem_t_tb, k_t, k_tb, mat12x2&
&              , mat12x2b)
      call popreal8array(pelem_t_t, 12*2)
      resb = 0.0_8
      resb = k_elemb
      mat12x2b = 0.0_8
      pelem_ab = 0.0_8
      call matmul2_b(12, 2, 12, mat12x2, mat12x2b, pelem_a, pelem_ab, &
&              res, resb)
      ea_l = e(ielem)*a(ielem)/l
      k_a(:, :) = ea_l*const2
      call popreal8array(mat12x2, 12*2)
      pelem_a_tb = 0.0_8
      k_ab = 0.0_8
      call matmul2_b(12, 2, 2, pelem_a_t, pelem_a_tb, k_a, k_ab, mat12x2&
&              , mat12x2b)
      call popreal8array(pelem_a_t, 12*2)
      call popreal8array(k_elem, 12**2)
      call popreal8array(k_z(:, 4), 4)
      lb = sum(k_z(:, 4)*k_zb(:, 4))
      k_zb(:, 4) = l*k_zb(:, 4)
      call popreal8array(k_z(:, 2), 4)
      lb = lb + sum(k_z(:, 2)*k_zb(:, 2))
      k_zb(:, 2) = l*k_zb(:, 2)
      call popreal8array(k_z(4, :), 4)
      lb = lb + sum(k_z(4, :)*k_zb(4, :))
      k_zb(4, :) = l*k_zb(4, :)
      call popreal8array(k_z(2, :), 4)
      lb = lb + sum(k_z(2, :)*k_zb(2, :))
      k_zb(2, :) = l*k_zb(2, :)
      call popreal8array(k_z, 4**2)
      eiz_l3b = sum(const_z*k_zb(:, :))
      call popreal8array(k_y(:, 4), 4)
      lb = lb + sum(k_y(:, 4)*k_yb(:, 4))
      k_yb(:, 4) = l*k_yb(:, 4)
      call popreal8array(k_y(:, 2), 4)
      lb = lb + sum(k_y(:, 2)*k_yb(:, 2))
      k_yb(:, 2) = l*k_yb(:, 2)
      call popreal8array(k_y(4, :), 4)
      lb = lb + sum(k_y(4, :)*k_yb(4, :))
      k_yb(4, :) = l*k_yb(4, :)
      call popreal8array(k_y(2, :), 4)
      lb = lb + sum(k_y(2, :)*k_yb(2, :))
      k_yb(2, :) = l*k_yb(2, :)
      call popreal8array(k_y, 4**2)
      eiy_l3b = sum(const_y*k_yb(:, :))
      gj_lb = sum(const2*k_tb(:, :))
      ea_lb = sum(const2*k_ab(:, :))
      temp0 = l**3
      tempb = e(ielem)*eiz_l3b/temp0
      izb(ielem) = izb(ielem) + tempb
      temp = l**3
      tempb0 = e(ielem)*eiy_l3b/temp
      iyb(ielem) = iyb(ielem) + tempb0
      tempb2 = g(ielem)*gj_lb/l
      jb(ielem) = jb(ielem) + tempb2
      tempb1 = e(ielem)*ea_lb/l
      lb = lb - iy(ielem)*3*l**2*tempb0/temp - a(ielem)*tempb1/l - j(&
&       ielem)*tempb2/l - iz(ielem)*3*l**2*tempb/temp0
      ab(ielem) = ab(ielem) + tempb1
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      arg1(:) = p1 - p0
      call popreal8(l)
      arg1b = 0.0_8
      call norm_b(arg1(:), arg1b(:), l, lb)
      p0b = 0.0_8
      p1b = 0.0_8
      p1b = arg1b(:)
      p0b = -arg1b(:)
      do ind=4,1,-1
        call popreal8array(t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3&
&                    *(ind-1)+3), 3**2)
        tb = tb + t_elemb(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)&
&         +3)
        t_elemb(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = &
&         0.0_8
      end do
      z_locb = z_locb + tb(3, :)
      tb(3, :) = 0.0_8
      y_locb = y_locb + tb(2, :)
      tb(2, :) = 0.0_8
      x_locb = x_locb + tb(1, :)
      tb(1, :) = 0.0_8
      call unit_b(y_cross, y_crossb, z_loc, z_locb)
      call popreal8array(y_cross, 3)
      call cross_b(x_loc, x_locb, y_loc, y_locb, y_cross, y_crossb)
      call popreal8array(y_loc, 3)
      call unit_b(x_cross, x_crossb, y_loc, y_locb)
      call popreal8array(x_cross, 3)
      x_glb = 0.0_8
      call cross_b(x_loc, x_locb, x_gl, x_glb, x_cross, x_crossb)
      arg1(:) = p1 - p0
      call popreal8array(x_loc, 3)
      arg1b = 0.0_8
      call unit_b(arg1(:), arg1b(:), x_loc, x_locb)
      p1b = p1b + arg1b
      p0b = p0b - arg1b
      nodesb(elem_ids(ielem, 2), :) = nodesb(elem_ids(ielem, 2), :) + &
&       p1b
      nodesb(elem_ids(ielem, 1), :) = nodesb(elem_ids(ielem, 1), :) + &
&       p0b
    end do
  end subroutine assemblestructmtx_main_b
! 6
! 4
! 3
! 3
! 6
  subroutine assemblestructmtx_main(n, tot_n_fem, size, nodes, a, j, iy&
&   , iz, k_a, k_t, k_y, k_z, elem_ids, cons, e, g, x_gl, t, k_elem, &
&   pelem_a, pelem_t, pelem_y, pelem_z, t_elem, const2, const_y, const_z&
&   , rhs, k, x)
! 7
    use solveroutines, only : solve
    implicit none
! input
    integer, intent(in) :: n, size, cons, tot_n_fem
    integer, intent(inout) :: elem_ids(n-1, 2)
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8), intent(in) :: e(n-1), g(n-1), x_gl(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4), rhs(size)
! output
    real(kind=8), intent(out) :: x(size), k(size, size)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(size, size)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)&
&   , b(size)
    integer :: ipiv(size), n_solve
    real(kind=8), dimension(3) :: arg1
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    k(:, :) = 0.
! loop over num elements
    do ielem=1,num_elems
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      arg1(:) = p1 - p0
      call unit(arg1(:), x_loc)
      call cross(x_loc, x_gl, x_cross)
      call unit(x_cross, y_loc)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do ind=1,4
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      arg1(:) = p1 - p0
      call norm(arg1(:), l)
      ea_l = e(ielem)*a(ielem)/l
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      k_y(:, :) = eiy_l3*const_y
      k_y(2, :) = k_y(2, :)*l
      k_y(4, :) = k_y(4, :)*l
      k_y(:, 2) = k_y(:, 2)*l
      k_y(:, 4) = k_y(:, 4)*l
      k_z(:, :) = eiz_l3*const_z
      k_z(2, :) = k_z(2, :)*l
      k_z(4, :) = k_z(4, :)*l
      k_z(:, 2) = k_z(:, 2)*l
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call matmul2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call matmul2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call matmul2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call matmul2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call transpose2(12, 12, t_elem, t_elem_t)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      call matmul2(12, 12, 12, mat12x12, t_elem, res)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
    n_solve = size
    b = rhs
    k_ = k
    call solve(k_, x, b, n_solve, ipiv)
  end subroutine assemblestructmtx_main
!  differentiation of transpose2 in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: new_mtx mtx
!   with respect to varying inputs: new_mtx mtx
  subroutine transpose2_b(m, n, mtx, mtxb, new_mtx, new_mtxb)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8) :: mtxb(m, n)
    real(kind=8) :: new_mtx(n, m)
    real(kind=8) :: new_mtxb(n, m)
    integer :: i, j
    do i=m,1,-1
      do j=n,1,-1
        mtxb(i, j) = mtxb(i, j) + new_mtxb(j, i)
        new_mtxb(j, i) = 0.0_8
      end do
    end do
  end subroutine transpose2_b
  subroutine transpose2(m, n, mtx, new_mtx)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8), intent(out) :: new_mtx(n, m)
    integer :: i, j
    do i=1,m
      do j=1,n
        new_mtx(j, i) = mtx(i, j)
      end do
    end do
  end subroutine transpose2
!  differentiation of matmul2 in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b
  subroutine matmul2_b(m, n, p, a, ab, b, bb, c, cb)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8) :: ab(m, n), bb(n, p)
    real(kind=8) :: c(m, p)
    real(kind=8) :: cb(m, p)
    integer :: i, j, k
    do i=m,1,-1
      do j=p,1,-1
        do k=n,1,-1
          ab(i, k) = ab(i, k) + b(k, j)*cb(i, j)
          bb(k, j) = bb(k, j) + a(i, k)*cb(i, j)
        end do
      end do
    end do
  end subroutine matmul2_b
  subroutine matmul2(m, n, p, a, b, c)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8), intent(out) :: c(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    do i=1,m
      do j=1,p
        do k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2
!  differentiation of unit in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
  subroutine unit_b(v, vb, u, ub)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8) :: vb(3)
    real(kind=8) :: u(3)
    real(kind=8) :: ub(3)
    real(kind=8) :: nm
    real(kind=8) :: nmb
    call norm(v, nm)
    vb(3) = vb(3) + ub(3)/nm
    nmb = -(v(3)*ub(3)/nm**2)
    ub(3) = 0.0_8
    vb(2) = vb(2) + ub(2)/nm
    nmb = nmb - v(2)*ub(2)/nm**2
    ub(2) = 0.0_8
    vb(1) = vb(1) + ub(1)/nm
    nmb = nmb - v(1)*ub(1)/nm**2
    ub(1) = 0.0_8
    call norm_b(v, vb, nm, nmb)
  end subroutine unit_b
!  differentiation of assembleaeromtx_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: mtx
!   with respect to varying inputs: alpha points mesh bpts mtx
!   rw status of diff variables: alpha:out points:out mesh:out
!                bpts:out mtx:in-zero
  subroutine assembleaeromtx_main_b(ny, nx, ny_, nx_, alpha, alphab, &
&   points, pointsb, bpts, bptsb, mesh, meshb, skip, symmetry, mtx, mtxb&
& )
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    real(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    real(kind=8) :: alphab, meshb(nx_, ny_, 3)
    real(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, ny_, &
&   3)
    real(kind=8) :: pointsb(nx-1, ny-1, 3), bptsb(nx_-1, ny_, 3)
    logical, intent(in) :: skip, symmetry
! output
    real(kind=8) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
    real(kind=8) :: mtxb((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    real(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    real(kind=8) :: pb(3), ab(3), bb(3), ub(3), cb(3), db(3)
    real(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    real(kind=8) :: a_symb(3), b_symb(3), c_symb(3), d_symb(3)
    real(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    real(kind=8) :: ur2b(3), r1b(3), r2b(3), r1_magb, r2_magb
    real(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    real(kind=8) :: ur1b(3), boundb(3), dot_ur2b, dot_ur1b
    real(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym(3)
    real(kind=8) :: edgesb(3), c_teb(3), d_teb(3), c_te_symb(3), &
&   d_te_symb(3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    integer :: branch
    real(kind=8) :: tempb6
    real(kind=8) :: tempb5(3)
    real(kind=8) :: tempb4
    real(kind=8) :: tempb3(3)
    real(kind=8) :: tempb2
    real(kind=8) :: tempb1(3)
    real(kind=8) :: tempb0
    real(kind=8) :: tempb(3)
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
    u(1) = cos(alpha*pi/180.)
    u(2) = 0.
    u(3) = sin(alpha*pi/180.)
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      call pushinteger4(el_loc_j)
      el_loc_j = (el_j-1)*(nx_-1)
      call pushreal8array(c_te, 3)
      c_te = mesh(nx_, el_j+1, :)
      call pushreal8array(d_te, 3)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          call pushinteger4(cp_loc)
          cp_loc = cp_i + cp_loc_j
          call pushreal8array(p, 3)
          p = points(cp_i, cp_j, :)
          call pushreal8array(r1, 3)
          r1 = p - d_te
          call pushreal8array(r2, 3)
          r2 = p - c_te
          call pushreal8(r1_mag)
          call norm(r1, r1_mag)
          call pushreal8(r2_mag)
          call norm(r2, r2_mag)
          call pushreal8array(ur2, 3)
          call cross(u, r2, ur2)
          call pushreal8array(ur1, 3)
          call cross(u, r1, ur1)
          call pushreal8(dot_ur2)
          call dot(u, r2, dot_ur2)
          call pushreal8(dot_ur1)
          call dot(u, r1, dot_ur1)
          if (symmetry) then
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            call pushreal8(r1_mag)
            call norm(r1, r1_mag)
            call pushreal8(r2_mag)
            call norm(r2, r2_mag)
            call pushreal8array(ur2, 3)
            call cross(u, r2, ur2)
            call pushreal8array(ur1, 3)
            call cross(u, r1, ur1)
            call pushreal8(dot_ur2)
            call dot(u, r2, dot_ur2)
            call pushreal8(dot_ur1)
            call dot(u, r1, dot_ur1)
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              call pushreal8array(c, 3)
              c = c_te
              call pushreal8array(d, 3)
              d = d_te
              call pushcontrol1b(0)
            else
              call pushreal8array(c, 3)
              c = bpts(el_i+1, el_j+1, :)
              call pushreal8array(d, 3)
              d = bpts(el_i+1, el_j+0, :)
              call pushcontrol1b(1)
            end if
            if (symmetry) then
              call pushreal8array(a_sym, 3)
              a_sym = a
              call pushreal8array(b_sym, 3)
              b_sym = b
              call pushreal8array(c_sym, 3)
              c_sym = c
              call pushreal8array(d_sym, 3)
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
            end if
            if (skip .and. cp_loc .eq. el_loc) then
              if (symmetry) then
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
              call pushcontrol1b(1)
            else
              if (symmetry) then
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
              call pushcontrol1b(0)
            end if
          end do
        end do
      end do
    end do
    pointsb = 0.0_8
    meshb = 0.0_8
    bptsb = 0.0_8
    ub = 0.0_8
    ur1b = 0.0_8
    ur2b = 0.0_8
    a_symb = 0.0_8
    c_te_symb = 0.0_8
    b_symb = 0.0_8
    d_te_symb = 0.0_8
    do el_j=ny_-1,1,-1
      c_teb = 0.0_8
      d_teb = 0.0_8
      do cp_j=ny-1,1,-1
        do cp_i=nx-1,1,-1
          pb = 0.0_8
          edgesb = 0.0_8
          do el_i=1,nx_-1,1
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              el_loc = el_i + el_loc_j
              boundb = 0.0_8
              edgesb = edgesb + mtxb(cp_loc, el_loc, :)
              boundb = mtxb(cp_loc, el_loc, :)
              mtxb(cp_loc, el_loc, :) = 0.0_8
              call popcontrol1b(branch)
              if (branch .eq. 0) call calc_vorticity_b(b_sym, b_symb, &
&                                                a_sym, a_symb, p, pb, &
&                                                bound, boundb)
              a = bpts(el_i+0, el_j+0, :)
              b = bpts(el_i+0, el_j+1, :)
              ab = 0.0_8
              bb = 0.0_8
              call calc_vorticity_b(a, ab, b, bb, p, pb, bound, boundb)
            else
              el_loc = el_i + el_loc_j
              boundb = 0.0_8
              edgesb = edgesb + mtxb(cp_loc, el_loc, :)
              boundb = mtxb(cp_loc, el_loc, :)
              mtxb(cp_loc, el_loc, :) = 0.0_8
              call popcontrol1b(branch)
              if (branch .eq. 0) call calc_vorticity_b(b_sym, b_symb, &
&                                                a_sym, a_symb, p, pb, &
&                                                bound, boundb)
              a = bpts(el_i+0, el_j+0, :)
              b = bpts(el_i+0, el_j+1, :)
              ab = 0.0_8
              bb = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              d_symb = 0.0_8
              call calc_vorticity_b(a_sym, a_symb, d_sym, d_symb, p, pb&
&                             , edges, edgesb)
              c_symb = 0.0_8
              call calc_vorticity_b(c_sym, c_symb, b_sym, b_symb, p, pb&
&                             , edges, edgesb)
              d_symb(2) = -d_symb(2)
              c_symb(2) = -c_symb(2)
              b_symb(2) = -b_symb(2)
              a_symb(2) = -a_symb(2)
              db = 0.0_8
              call popreal8array(d_sym, 3)
              db = d_symb
              cb = 0.0_8
              call popreal8array(c_sym, 3)
              cb = c_symb
              call popreal8array(b_sym, 3)
              bb = bb + b_symb
              call popreal8array(a_sym, 3)
              ab = ab + a_symb
              a_symb = 0.0_8
              b_symb = 0.0_8
            else
              db = 0.0_8
              cb = 0.0_8
            end if
            call calc_vorticity_b(d, db, a, ab, p, pb, edges, edgesb)
            call calc_vorticity_b(b, bb, c, cb, p, pb, edges, edgesb)
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popreal8array(d, 3)
              d_teb = d_teb + db
              call popreal8array(c, 3)
              c_teb = c_teb + cb
            else
              call popreal8array(d, 3)
              bptsb(el_i+1, el_j+0, :) = bptsb(el_i+1, el_j+0, :) + db
              call popreal8array(c, 3)
              bptsb(el_i+1, el_j+1, :) = bptsb(el_i+1, el_j+1, :) + cb
            end if
            bptsb(el_i+0, el_j+1, :) = bptsb(el_i+0, el_j+1, :) + bb
            bptsb(el_i+0, el_j+0, :) = bptsb(el_i+0, el_j+0, :) + ab
          end do
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            tempb3 = edgesb/(r1_mag*(r1_mag-dot_ur1))
            tempb4 = sum(-(ur1*tempb3/(r1_mag*(r1_mag-dot_ur1))))
            ur1b = ur1b + tempb3
            r1_magb = (2*r1_mag-dot_ur1)*tempb4
            dot_ur1b = -(r1_mag*tempb4)
            tempb5 = -(edgesb/(r2_mag*(r2_mag-dot_ur2)))
            tempb6 = sum(-(ur2*tempb5/(r2_mag*(r2_mag-dot_ur2))))
            ur2b = ur2b + tempb5
            r2_magb = (2*r2_mag-dot_ur2)*tempb6
            dot_ur2b = -(r2_mag*tempb6)
            call popreal8(dot_ur1)
            r1b = 0.0_8
            call dot_b(u, ub, r1, r1b, dot_ur1, dot_ur1b)
            call popreal8(dot_ur2)
            r2b = 0.0_8
            call dot_b(u, ub, r2, r2b, dot_ur2, dot_ur2b)
            call popreal8array(ur1, 3)
            call cross_b(u, ub, r1, r1b, ur1, ur1b)
            call popreal8array(ur2, 3)
            call cross_b(u, ub, r2, r2b, ur2, ur2b)
            call popreal8(r2_mag)
            call norm_b(r2, r2b, r2_mag, r2_magb)
            call popreal8(r1_mag)
            call norm_b(r1, r1b, r1_mag, r1_magb)
            pb = pb + r1b + r2b
            c_te_symb = c_te_symb - r2b
            d_te_symb = d_te_symb - r1b
          end if
          tempb = -(edgesb/(r1_mag*(r1_mag-dot_ur1)))
          tempb0 = sum(-(ur1*tempb/(r1_mag*(r1_mag-dot_ur1))))
          ur1b = ur1b + tempb
          r1_magb = (2*r1_mag-dot_ur1)*tempb0
          dot_ur1b = -(r1_mag*tempb0)
          tempb1 = edgesb/(r2_mag*(r2_mag-dot_ur2))
          tempb2 = sum(-(ur2*tempb1/(r2_mag*(r2_mag-dot_ur2))))
          ur2b = ur2b + tempb1
          r2_magb = (2*r2_mag-dot_ur2)*tempb2
          dot_ur2b = -(r2_mag*tempb2)
          r1 = p - d_te
          call popreal8(dot_ur1)
          r1b = 0.0_8
          call dot_b(u, ub, r1, r1b, dot_ur1, dot_ur1b)
          r2 = p - c_te
          call popreal8(dot_ur2)
          r2b = 0.0_8
          call dot_b(u, ub, r2, r2b, dot_ur2, dot_ur2b)
          call popreal8array(ur1, 3)
          call cross_b(u, ub, r1, r1b, ur1, ur1b)
          call popreal8array(ur2, 3)
          call cross_b(u, ub, r2, r2b, ur2, ur2b)
          call popreal8(r2_mag)
          call norm_b(r2, r2b, r2_mag, r2_magb)
          call popreal8(r1_mag)
          call norm_b(r1, r1b, r1_mag, r1_magb)
          call popreal8array(r2, 3)
          pb = pb + r1b + r2b
          c_teb = c_teb - r2b
          call popreal8array(r1, 3)
          d_teb = d_teb - r1b
          call popreal8array(p, 3)
          pointsb(cp_i, cp_j, :) = pointsb(cp_i, cp_j, :) + pb
          call popinteger4(cp_loc)
        end do
      end do
      call popcontrol1b(branch)
      if (branch .ne. 0) then
        d_te_symb(2) = -d_te_symb(2)
        c_te_symb(2) = -c_te_symb(2)
        d_teb = d_teb + d_te_symb
        c_teb = c_teb + c_te_symb
        c_te_symb = 0.0_8
        d_te_symb = 0.0_8
      end if
      call popreal8array(d_te, 3)
      meshb(nx_, el_j+0, :) = meshb(nx_, el_j+0, :) + d_teb
      call popreal8array(c_te, 3)
      meshb(nx_, el_j+1, :) = meshb(nx_, el_j+1, :) + c_teb
      call popinteger4(el_loc_j)
    end do
    alphab = pi*cos(pi*(alpha/180.))*ub(3)/180.
    ub(3) = 0.0_8
    ub(2) = 0.0_8
    alphab = alphab - pi*sin(pi*(alpha/180.))*ub(1)/180.
    mtxb = 0.0_8
  end subroutine assembleaeromtx_main_b
  subroutine assembleaeromtx_main(ny, nx, ny_, nx_, alpha, points, bpts&
&   , mesh, skip, symmetry, mtx)
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    real(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    real(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, ny_, &
&   3)
    logical, intent(in) :: skip, symmetry
! output
    real(kind=8), intent(out) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    real(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    real(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    real(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    real(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    real(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym(3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
    u(1) = cos(alpha*pi/180.)
    u(2) = 0.
    u(3) = sin(alpha*pi/180.)
    mtx(:, :, :) = 0.
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_te = mesh(nx_, el_j+1, :)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          p = points(cp_i, cp_j, :)
          r1 = p - d_te
          r2 = p - c_te
          call norm(r1, r1_mag)
          call norm(r2, r2_mag)
          call cross(u, r2, ur2)
          call cross(u, r1, ur1)
          edges(:) = 0.
          call dot(u, r2, dot_ur2)
          call dot(u, r1, dot_ur1)
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          if (symmetry) then
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            call norm(r1, r1_mag)
            call norm(r2, r2_mag)
            call cross(u, r2, ur2)
            call cross(u, r1, ur1)
            call dot(u, r2, dot_ur2)
            call dot(u, r1, dot_ur1)
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              c = c_te
              d = d_te
            else
              c = bpts(el_i+1, el_j+1, :)
              d = bpts(el_i+1, el_j+0, :)
            end if
            call calc_vorticity(b, c, p, edges)
            call calc_vorticity(d, a, p, edges)
            if (symmetry) then
              a_sym = a
              b_sym = b
              c_sym = c
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              call calc_vorticity(c_sym, b_sym, p, edges)
              call calc_vorticity(a_sym, d_sym, p, edges)
            end if
            if (skip .and. cp_loc .eq. el_loc) then
              bound(:) = 0.
              if (symmetry) call calc_vorticity(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            else
              bound(:) = 0.
              call calc_vorticity(a, b, p, bound)
              if (symmetry) call calc_vorticity(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            end if
          end do
        end do
      end do
    end do
  end subroutine assembleaeromtx_main
!  differentiation of calc_vorticity in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: p out a b
!   with respect to varying inputs: p out a b
  subroutine calc_vorticity_b(a, ab, b, bb, p, pb, out, outb)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
    real(kind=8) :: ab(3), bb(3), pb(3)
! output
    real(kind=8), intent(inout) :: out(3)
    real(kind=8) :: outb(3)
! working
    real(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    real(kind=8) :: r1b(3), r2b(3), r1_magb, r2_magb, r1r2b(3), &
&   mag_multb, dot_r1r2b
    real(kind=8) :: tempb0
    real(kind=8) :: tempb(3)
    r1 = p - a
    r2 = p - b
    call norm(r1, r1_mag)
    call norm(r2, r2_mag)
    call cross(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    call dot(r1, r2, dot_r1r2)
    r1r2b = 0.0_8
    tempb = outb/(mag_mult*(mag_mult+dot_r1r2))
    tempb0 = sum(-((r1_mag+r2_mag)*r1r2*tempb/(mag_mult*(mag_mult+&
&     dot_r1r2))))
    r1r2b = (r1_mag+r2_mag)*tempb
    mag_multb = (2*mag_mult+dot_r1r2)*tempb0
    r1_magb = r2_mag*mag_multb + sum(r1r2*tempb)
    r2_magb = r1_mag*mag_multb + sum(r1r2*tempb)
    dot_r1r2b = mag_mult*tempb0
    r1b = 0.0_8
    r2b = 0.0_8
    call dot_b(r1, r1b, r2, r2b, dot_r1r2, dot_r1r2b)
    call cross_b(r1, r1b, r2, r2b, r1r2, r1r2b)
    call norm_b(r2, r2b, r2_mag, r2_magb)
    call norm_b(r1, r1b, r1_mag, r1_magb)
    pb = pb + r1b + r2b
    bb = bb - r2b
    ab = ab - r1b
  end subroutine calc_vorticity_b
  subroutine calc_vorticity(a, b, p, out)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
! output
    real(kind=8), intent(inout) :: out(3)
! working
    real(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    r1 = p - a
    r2 = p - b
    call norm(r1, r1_mag)
    call norm(r2, r2_mag)
    call cross(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    call dot(r1, r2, dot_r1r2)
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  end subroutine calc_vorticity
  subroutine biotsavart(a, b, p, inf, rev, out)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
    logical, intent(in) :: inf, rev
! output
    real(kind=8), intent(inout) :: out(3)
! working
    real(kind=8) :: rpa, rpb, rab, rh
    real(kind=8) :: cosa, cosb, c(3)
    real(kind=8) :: eps, tmp(3), dot_bapa, dot_baba, dot_pbab
    real(kind=8), dimension(3) :: arg1
    real(kind=8), dimension(3) :: arg2
    eps = 1e-5
    arg1(:) = a - p
    call norm(arg1(:), rpa)
    arg1(:) = b - p
    call norm(arg1(:), rpb)
    arg1(:) = b - a
    call norm(arg1(:), rab)
    arg1(:) = b - a
    arg2(:) = p - a
    call dot(arg1(:), arg2(:), dot_bapa)
    arg1(:) = b - a
    arg2(:) = b - a
    call dot(arg1(:), arg2(:), dot_baba)
    arg1(:) = p - b
    arg2(:) = a - b
    call dot(arg1(:), arg2(:), dot_pbab)
    arg1(:) = p - a - dot_bapa/dot_baba*(b-a)
    call norm(arg1(:), rh)
    rh = rh + eps
    cosa = dot_bapa/(rpa*rab)
    cosb = dot_pbab/(rpb*rab)
    arg1(:) = b - p
    arg2(:) = a - p
    call cross(arg1(:), arg2(:), c)
    call unit(c, c)
    if (inf) then
      tmp = -(c/rh*(cosa+1))
    else
      tmp = -(c/rh*(cosa+cosb))
    end if
    if (rev) tmp = -tmp
    out = out + tmp
  end subroutine biotsavart
  subroutine unit(v, u)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: u(3)
    real(kind=8) :: nm
    call norm(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  end subroutine unit
!  differentiation of norm in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: v norm_output
!   with respect to varying inputs: v
  subroutine norm_b(v, vb, norm_output, norm_outputb)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8) :: vb(3)
    real(kind=8) :: norm_output
    real(kind=8) :: norm_outputb
    real(kind=8) :: dot_prod
    real(kind=8) :: dot_prodb
!norm = sqrt(dot_product(v, v))
    call dot(v, v, dot_prod)
    dot_prodb = 0.5*dot_prod**(-0.5)*norm_outputb
    call dot_b(v, vb, v, vb, dot_prod, dot_prodb)
  end subroutine norm_b
  subroutine norm(v, norm_output)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: norm_output
    real(kind=8) :: dot_prod
!norm = sqrt(dot_product(v, v))
    call dot(v, v, dot_prod)
    norm_output = dot_prod**0.5
  end subroutine norm
!  differentiation of dot in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: dot_prod a b
!   with respect to varying inputs: a b
  subroutine dot_b(a, ab, b, bb, dot_prod, dot_prodb)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8) :: ab(3), bb(3)
    real(kind=8) :: dot_prod
    real(kind=8) :: dot_prodb
    ab(1) = ab(1) + b(1)*dot_prodb
    bb(1) = bb(1) + a(1)*dot_prodb
    ab(2) = ab(2) + b(2)*dot_prodb
    bb(2) = bb(2) + a(2)*dot_prodb
    ab(3) = ab(3) + b(3)*dot_prodb
    bb(3) = bb(3) + a(3)*dot_prodb
  end subroutine dot_b
  subroutine dot(a, b, dot_prod)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot
!  differentiation of cross in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b c
  subroutine cross_b(a, ab, b, bb, c, cb)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8) :: ab(3), bb(3)
    real(kind=8) :: c(3)
    real(kind=8) :: cb(3)
    ab(1) = ab(1) + b(2)*cb(3)
    bb(2) = bb(2) + a(1)*cb(3)
    ab(2) = ab(2) - b(1)*cb(3)
    bb(1) = bb(1) - a(2)*cb(3)
    cb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*cb(2)
    bb(1) = bb(1) + a(3)*cb(2)
    ab(1) = ab(1) - b(3)*cb(2)
    bb(3) = bb(3) - a(1)*cb(2)
    cb(2) = 0.0_8
    ab(2) = ab(2) + b(3)*cb(1)
    bb(3) = bb(3) + a(2)*cb(1)
    ab(3) = ab(3) - b(2)*cb(1)
    bb(2) = bb(2) - a(3)*cb(1)
    cb(1) = 0.0_8
  end subroutine cross_b
  subroutine cross(a, b, c)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross
end module oas_main_b
