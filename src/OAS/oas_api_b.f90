!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
!
MODULE OAS_API_B
  IMPLICIT NONE

CONTAINS
!  Differentiation of mult in reverse (adjoint) mode:
!   gradient     of useful results: x y
!   with respect to varying inputs: x y
!   RW status of diff variables: x:incr y:in-zero
  SUBROUTINE MULT_B(nx, ny, x, xb, y, yb)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nx, ny
    REAL*8, INTENT(IN) :: x(nx)
    REAL*8 :: xb(nx)
    REAL*8 :: y(ny)
    REAL*8 :: yb(ny)
    INTEGER :: i, j
    DO j=ny,1,-1
      DO i=nx,1,-1
        xb(i) = xb(i) + 2*x(i)*yb(j)
      END DO
    END DO
    yb = 0.0_8
  END SUBROUTINE MULT_B
  SUBROUTINE MULT(nx, ny, x, y)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nx, ny
    REAL*8, INTENT(IN) :: x(nx)
    REAL*8, INTENT(OUT) :: y(ny)
    INTEGER :: i, j
    y(:) = 0.
    DO j=1,ny
      DO i=1,nx
        y(j) = y(j) + x(i)**2
      END DO
    END DO
  END SUBROUTINE MULT
  SUBROUTINE ASSEMBLESPARSEMTX(num_elems, tot_n_fem, nnz, x_gl, e, g, a&
&   , j, iy, iz, nodes, elems, coeff_at, coeff_y, coeff_z, pelem_a, &
&   pelem_t, pelem_y, pelem_z, data, rows, cols)
    IMPLICIT NONE
! Input
    INTEGER, INTENT(IN) :: tot_n_fem, num_elems, nnz
    COMPLEX(kind=8), INTENT(IN) :: x_gl(3)
    COMPLEX(kind=8), INTENT(IN) :: e(num_elems), g(num_elems)
    COMPLEX(kind=8), INTENT(IN) :: a(num_elems), j(num_elems)
    COMPLEX(kind=8), INTENT(IN) :: iy(num_elems), iz(num_elems)
    COMPLEX(kind=8), INTENT(IN) :: nodes(tot_n_fem, 3)
    INTEGER, INTENT(IN) :: elems(num_elems, 2)
! Local stiffness matrix coefficients
    COMPLEX(kind=8), INTENT(IN) :: coeff_at(2, 2), coeff_y(4, 4), &
&   coeff_z(4, 4)
! Local permutation matrices to map to list of dofs for local element
    COMPLEX(kind=8), INTENT(IN) :: pelem_a(2, 12), pelem_t(2, 12)
    COMPLEX(kind=8), INTENT(IN) :: pelem_y(4, 12), pelem_z(4, 12)
! Output
    COMPLEX(kind=8), INTENT(OUT) :: data(nnz)
    INTEGER, INTENT(OUT) :: rows(nnz), cols(nnz)
! Local stiffness matrices for axial, torsion, bending (y,z)
    COMPLEX(kind=8) :: kelem_a(2, 2), kelem_t(2, 2)
    COMPLEX(kind=8) :: kelem_y(4, 4), kelem_z(4, 4)
! Local transformation matrix (12,12) to map from local to global frame
    COMPLEX(kind=8) :: t_elem(12, 12), t(3, 3)
! Arrays that help in mapping from local element ordering to global ordering
    INTEGER :: rows_elem(12, 12), cols_elem(12, 12)
    INTEGER :: ones11(12, 12), ones12(12, 12)
    INTEGER :: ones21(12, 12), ones22(12, 12)
! Local stiffness matrix in global frame
    COMPLEX(kind=8) :: k_elem(12, 12)
! Miscellaneous
    COMPLEX(kind=8) :: l, xyz1(3), xyz2(3)
    COMPLEX(kind=8) :: x_loc(3), y_loc(3), z_loc(3), x_cross(3), y_cross&
&   (3)
    COMPLEX(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)&
&   , res(12, 12)
    COMPLEX(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2)
    COMPLEX(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, &
&   12)
    INTEGER :: i, k1, k2, ind, ind1, ind2, ielem
    INTRINSIC MOD
    COMPLEX(kind=8), DIMENSION(3) :: arg1
    DO k1=1,12
      DO k2=1,12
        rows_elem(k1, k2) = MOD(k1 - 1, 6)
        cols_elem(k1, k2) = MOD(k2 - 1, 6)
      END DO
    END DO
    ones11(:, :) = 0
    ones12(:, :) = 0
    ones21(:, :) = 0
    ones22(:, :) = 0
    ones11(1:6, 1:6) = 1
    ones12(1:6, 7:12) = 1
    ones21(7:12, 1:6) = 1
    ones22(7:12, 7:12) = 1
    t_elem(:, :) = 0.
    data(:) = 0.
    rows(:) = 0
    cols(:) = 0
    ind = 0
    DO ielem=1,num_elems
      xyz1 = nodes(elems(ielem, 1), :)
      xyz2 = nodes(elems(ielem, 2), :)
      arg1(:) = xyz2 - xyz1
      CALL NORM(arg1(:), l)
      arg1(:) = xyz2 - xyz1
      CALL UNIT(arg1(:), x_loc)
      CALL CROSS(x_loc, x_gl, x_cross)
      CALL UNIT(x_cross, y_loc)
      CALL CROSS(x_loc, y_loc, y_cross)
      CALL UNIT(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      DO i=1,4
        t_elem(3*(i-1)+1:3*(i-1)+3, 3*(i-1)+1:3*(i-1)+3) = t
      END DO
      kelem_a = coeff_at*e(ielem)*a(ielem)/l
      kelem_t = coeff_at*g(ielem)*j(ielem)/l
      kelem_y = coeff_y*e(ielem)*iy(ielem)/l**3
      kelem_y(2:4:2, :) = kelem_y(2:4:2, :)*l
      kelem_y(:, 2:4:2) = kelem_y(:, 2:4:2)*l
      kelem_z = coeff_z*e(ielem)*iz(ielem)/l**3
      kelem_z(2:4:2, :) = kelem_z(2:4:2, :)*l
      kelem_z(:, 2:4:2) = kelem_z(:, 2:4:2)*l
      k_elem(:, :) = 0.
      CALL TRANSPOSE2(2, 12, pelem_a, pelem_a_t)
      CALL MATMUL2(12, 2, 2, pelem_a_t, kelem_a, mat12x2)
      CALL MATMUL2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(2, 12, pelem_t, pelem_t_t)
      CALL MATMUL2(12, 2, 2, pelem_t_t, kelem_t, mat12x2)
      CALL MATMUL2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(4, 12, pelem_y, pelem_y_t)
      CALL MATMUL2(12, 4, 4, pelem_y_t, kelem_y, mat12x4)
      CALL MATMUL2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(4, 12, pelem_z, pelem_z_t)
      CALL MATMUL2(12, 4, 4, pelem_z_t, kelem_z, mat12x4)
      CALL MATMUL2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(12, 12, t_elem, t_elem_t)
      CALL MATMUL2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      CALL MATMUL2(12, 12, 12, mat12x12, t_elem, k_elem)
      ind1 = 6*(elems(ielem, 1)-1)
      ind2 = 6*(elems(ielem, 2)-1)
      DO k1=1,12
        DO k2=1,12
          ind = ind + 1
          data(ind) = data(ind) + k_elem(k1, k2)
          rows(ind) = rows(ind) + rows_elem(k1, k2) + 1
          cols(ind) = cols(ind) + cols_elem(k1, k2) + 1
          rows(ind) = rows(ind) + ones11(k1, k2)*ind1
          cols(ind) = cols(ind) + ones11(k1, k2)*ind1
          rows(ind) = rows(ind) + ones12(k1, k2)*ind1
          cols(ind) = cols(ind) + ones12(k1, k2)*ind2
          rows(ind) = rows(ind) + ones21(k1, k2)*ind2
          cols(ind) = cols(ind) + ones21(k1, k2)*ind1
          rows(ind) = rows(ind) + ones22(k1, k2)*ind2
          cols(ind) = cols(ind) + ones22(k1, k2)*ind2
        END DO
      END DO
    END DO
    IF (ind .NE. nnz) PRINT*, &
&         'Error in assemblesparsemtx: did not reach end of nnz vectors'
    rows(:) = rows(:) - 1
    cols(:) = cols(:) - 1
  END SUBROUTINE ASSEMBLESPARSEMTX
! 6
! 4
! 3
! 3
! 6
  SUBROUTINE ASSEMBLESTRUCTMTX(n, tot_n_fem, size, nodes, a, j, iy, iz, &
&   k_a, k_t, k_y, k_z, elem_ids, cons, e, g, x_gl, t, k_elem, pelem_a, &
&   pelem_t, pelem_y, pelem_z, t_elem, const2, const_y, const_z, k)
    IMPLICIT NONE
!f2py intent(in)   n, tot_n_fem, size, elem_IDs, cons, nodes, A, J, Iy, Iz, E, G, x_gl, K_a, K_t, K_y, K_z, T, K_elem, Pelem_a, P
!elem_t, Pelem_y, Pelem_z, T_elem, const2, const_y, const_z
!f2py intent(out) K
!f2py depends(tot_n_fem) nodes
!f2py depends(n) elem_IDs, nodes, A, J, Iy, Iz, E, G
!f2py depends(size) K
! Input
    INTEGER, INTENT(IN) :: n, size, cons, tot_n_fem
    INTEGER, INTENT(INOUT) :: elem_ids(n-1, 2)
    COMPLEX(kind=8), INTENT(IN) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), &
&   iy(n-1), iz(n-1)
    COMPLEX(kind=8), INTENT(IN) :: e(n-1), g(n-1), x_gl(3)
    COMPLEX(kind=8), INTENT(INOUT) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), &
&   k_z(4, 4)
    COMPLEX(kind=8), INTENT(INOUT) :: t(3, 3), k_elem(12, 12), t_elem(12&
&   , 12)
    COMPLEX(kind=8), INTENT(IN) :: pelem_a(2, 12), pelem_t(2, 12), &
&   pelem_y(4, 12), pelem_z(4, 12)
    COMPLEX(kind=8), INTENT(IN) :: const2(2, 2), const_y(4, 4), const_z(&
&   4, 4)
! Output
    COMPLEX(kind=8), INTENT(OUT) :: k(size, size)
! Working
    COMPLEX(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), &
&   x_cross(3), y_cross(3)
    COMPLEX(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    COMPLEX(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    INTEGER :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    COMPLEX(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2)
    COMPLEX(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, &
&   12)
    COMPLEX(kind=8), DIMENSION(3) :: arg1
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    k(:, :) = 0.
! loop over num elements
    DO ielem=1,num_elems
      p0 = nodes(elem_ids(ielem, 1), :)
      p1 = nodes(elem_ids(ielem, 2), :)
      arg1(:) = p1 - p0
      CALL UNIT(arg1(:), x_loc)
      CALL CROSS(x_loc, x_gl, x_cross)
      CALL UNIT(x_cross, y_loc)
      CALL CROSS(x_loc, y_loc, y_cross)
      CALL UNIT(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      DO ind=1,4
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      END DO
      arg1(:) = p1 - p0
      CALL NORM(arg1(:), l)
      ea_l = e(ielem)*a(ielem)/l
      gj_l = g(ielem)*j(ielem)/l
      eiy_l3 = e(ielem)*iy(ielem)/l**3
      eiz_l3 = e(ielem)*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      k_y(:, :) = eiy_l3*const_y
      k_y(2, :) = k_y(2, :)*l
      k_y(4, :) = k_y(4, :)*l
      k_y(:, 2) = k_y(:, 2)*l
      k_y(:, 4) = k_y(:, 4)*l
      k_z(:, :) = eiz_l3*const_z
      k_z(2, :) = k_z(2, :)*l
      k_z(4, :) = k_z(4, :)*l
      k_z(:, 2) = k_z(:, 2)*l
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      CALL TRANSPOSE2(2, 12, pelem_a, pelem_a_t)
      CALL MATMUL2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      CALL MATMUL2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(2, 12, pelem_t, pelem_t_t)
      CALL MATMUL2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      CALL MATMUL2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(4, 12, pelem_y, pelem_y_t)
      CALL MATMUL2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      CALL MATMUL2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(4, 12, pelem_z, pelem_z_t)
      CALL MATMUL2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      CALL MATMUL2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      CALL TRANSPOSE2(12, 12, t_elem, t_elem_t)
      CALL MATMUL2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      CALL MATMUL2(12, 12, 12, mat12x12, t_elem, res)
      in0 = elem_ids(ielem, 1)
      in1 = elem_ids(ielem, 2)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    END DO
    DO i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    END DO
  END SUBROUTINE ASSEMBLESTRUCTMTX
  SUBROUTINE TRANSPOSE2(m, n, mtx, new_mtx)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: m, n
    COMPLEX(kind=8), INTENT(IN) :: mtx(m, n)
    COMPLEX(kind=8), INTENT(OUT) :: new_mtx(n, m)
    INTEGER :: i, j
    DO i=1,m
      DO j=1,n
        new_mtx(j, i) = mtx(i, j)
      END DO
    END DO
  END SUBROUTINE TRANSPOSE2
  SUBROUTINE MATMUL2(m, n, p, a, b, c)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: m, n, p
    COMPLEX(kind=8), INTENT(IN) :: a(m, n), b(n, p)
    COMPLEX(kind=8), INTENT(OUT) :: c(m, p)
    INTEGER :: i, j, k
    c(:, :) = 0.
    DO i=1,m
      DO j=1,p
        DO k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        END DO
      END DO
    END DO
  END SUBROUTINE MATMUL2
  SUBROUTINE ASSEMBLEAEROMTX(ny, nx, ny_, nx_, alpha, points, bpts, mesh&
&   , skip, symmetry, mtx)
    IMPLICIT NONE
! Input
    INTEGER, INTENT(IN) :: ny, nx, ny_, nx_
    COMPLEX(kind=8), INTENT(IN) :: alpha, mesh(nx_, ny_, 3)
    COMPLEX(kind=8), INTENT(IN) :: points(nx-1, ny-1, 3), bpts(nx_-1, &
&   ny_, 3)
    LOGICAL, INTENT(IN) :: skip, symmetry
! Output
    COMPLEX(kind=8), INTENT(OUT) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), &
&   3)
! Working
    INTEGER :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    COMPLEX(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    COMPLEX(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    COMPLEX(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    COMPLEX(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    COMPLEX(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym&
&   (3)
    INTRINSIC ATAN
    INTRINSIC COS
    INTRINSIC SIN
    pi = 4.d0*ATAN(1.d0)
! Trailing vortices in AVL follow the x-axis; no cos or sin
    u(1) = COS(alpha*pi/180.)
    u(2) = 0.
    u(3) = SIN(alpha*pi/180.)
    mtx(:, :, :) = 0.
! spanwise loop through horseshoe elements
    DO el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_te = mesh(nx_, el_j+1, :)
      d_te = mesh(nx_, el_j+0, :)
      IF (symmetry) THEN
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
      END IF
! spanwise loop through control points
      DO cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        DO cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          p = points(cp_i, cp_j, :)
          r1 = p - d_te
          r2 = p - c_te
          CALL NORM(r1, r1_mag)
          CALL NORM(r2, r2_mag)
          CALL CROSS(u, r2, ur2)
          CALL CROSS(u, r1, ur1)
          edges(:) = 0.
          CALL DOT(u, r2, dot_ur2)
          CALL DOT(u, r1, dot_ur1)
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          IF (symmetry) THEN
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            CALL NORM(r1, r1_mag)
            CALL NORM(r2, r2_mag)
            CALL CROSS(u, r2, ur2)
            CALL CROSS(u, r1, ur1)
            CALL DOT(u, r2, dot_ur2)
            CALL DOT(u, r1, dot_ur1)
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          END IF
! chordwise loop through horseshoe elements
          DO el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            IF (el_i .EQ. nx_ - 1) THEN
              c = c_te
              d = d_te
            ELSE
              c = bpts(el_i+1, el_j+1, :)
              d = bpts(el_i+1, el_j+0, :)
            END IF
            CALL CALC_VORTICITY(b, c, p, edges)
            CALL CALC_VORTICITY(d, a, p, edges)
            IF (symmetry) THEN
              a_sym = a
              b_sym = b
              c_sym = c
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              CALL CALC_VORTICITY(c_sym, b_sym, p, edges)
              CALL CALC_VORTICITY(a_sym, d_sym, p, edges)
            END IF
            IF (skip .AND. cp_loc .EQ. el_loc) THEN
              bound(:) = 0.
              IF (symmetry) CALL CALC_VORTICITY(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            ELSE
              bound(:) = 0.
              CALL CALC_VORTICITY(a, b, p, bound)
              IF (symmetry) CALL CALC_VORTICITY(b_sym, a_sym, p, bound)
              mtx(cp_loc, el_loc, :) = edges + bound
            END IF
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE ASSEMBLEAEROMTX
  SUBROUTINE CALC_VORTICITY(a, b, p, out)
    IMPLICIT NONE
! Input
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3), p(3)
! Output
    COMPLEX(kind=8), INTENT(INOUT) :: out(3)
! Working
    COMPLEX(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    r1 = p - a
    r2 = p - b
    CALL NORM(r1, r1_mag)
    CALL NORM(r2, r2_mag)
    CALL CROSS(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    CALL DOT(r1, r2, dot_r1r2)
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  END SUBROUTINE CALC_VORTICITY
  SUBROUTINE BIOTSAVART(a, b, p, inf, rev, out)
    IMPLICIT NONE
! Input
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3), p(3)
    LOGICAL, INTENT(IN) :: inf, rev
! Output
    COMPLEX(kind=8), INTENT(INOUT) :: out(3)
! Working
    COMPLEX(kind=8) :: rpa, rpb, rab, rh
    COMPLEX(kind=8) :: cosa, cosb, c(3)
    COMPLEX(kind=8) :: eps, tmp(3), dot_bapa, dot_baba, dot_pbab
    COMPLEX(kind=8), DIMENSION(3) :: arg1
    COMPLEX(kind=8), DIMENSION(3) :: arg2
    eps = 1e-5
    arg1(:) = a - p
    CALL NORM(arg1(:), rpa)
    arg1(:) = b - p
    CALL NORM(arg1(:), rpb)
    arg1(:) = b - a
    CALL NORM(arg1(:), rab)
    arg1(:) = b - a
    arg2(:) = p - a
    CALL DOT(arg1(:), arg2(:), dot_bapa)
    arg1(:) = b - a
    arg2(:) = b - a
    CALL DOT(arg1(:), arg2(:), dot_baba)
    arg1(:) = p - b
    arg2(:) = a - b
    CALL DOT(arg1(:), arg2(:), dot_pbab)
    arg1(:) = p - a - dot_bapa/dot_baba*(b-a)
    CALL NORM(arg1(:), rh)
    rh = rh + eps
    cosa = dot_bapa/(rpa*rab)
    cosb = dot_pbab/(rpb*rab)
    arg1(:) = b - p
    arg2(:) = a - p
    CALL CROSS(arg1(:), arg2(:), c)
    CALL UNIT(c, c)
    IF (inf) THEN
      tmp = -(c/rh*(cosa+1))
    ELSE
      tmp = -(c/rh*(cosa+cosb))
    END IF
    IF (rev) tmp = -tmp
    out = out + tmp
  END SUBROUTINE BIOTSAVART
  SUBROUTINE UNIT(v, u)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: v(3)
    COMPLEX(kind=8), INTENT(OUT) :: u(3)
    COMPLEX(kind=8) :: nm
    CALL NORM(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  END SUBROUTINE UNIT
  SUBROUTINE NORM(v, norm_output)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: v(3)
    COMPLEX(kind=8), INTENT(OUT) :: norm_output
    COMPLEX(kind=8) :: dot_prod
!norm = sqrt(dot_product(v, v))
    CALL DOT(v, v, dot_prod)
    norm_output = dot_prod**0.5
  END SUBROUTINE NORM
  SUBROUTINE DOT(a, b, dot_prod)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3)
    COMPLEX(kind=8), INTENT(OUT) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  END SUBROUTINE DOT
  SUBROUTINE CROSS(a, b, c)
    IMPLICIT NONE
    COMPLEX(kind=8), INTENT(IN) :: a(3), b(3)
    COMPLEX(kind=8), INTENT(OUT) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS
END MODULE OAS_API_B
